function draw_network_o3()
% DRAW_NETWORK_O3  Visualise branch networks and cable lengths.
%   The networks follow the syntax documented in README.md.
%   This script reads:
%       * networks.csv          –  list of networks to draw (ID, Network)
%       * cable_logs.csv        –  measured cable lengths per wire
%   A figure window is generated for every network in networks.csv, showing
%   the branch hierarchy as a directed graph.  Each node label contains the
%   wire name, its cable length (if available) and optional termination
%   code (e.g. [O], [S], [T], [R=..]).
%
%   Place this file in   branch_tests/scripts/   (already done) and run
%       >> draw_network_o3
%
%   Author: Auto-generated by Cursor-GPT, 2025-05-22

% -------------------------------------------------------------------------
% Locate data files -------------------------------------------------------
thisFile = mfilename('fullpath');
[thisDir, ~] = fileparts(thisFile);                % .../branch_tests/scripts
branchTestsDir   = fileparts(thisDir);             % .../branch_tests
projectRootDir   = fileparts(branchTestsDir);      % .../bnc_network

networksPath = fullfile(branchTestsDir, '2025-05-21', 'networks.csv');
logsPath     = fullfile(projectRootDir, 'cable_measurements', 'cable_logs.csv');

assert(isfile(networksPath), 'Could not find networks.csv at %s', networksPath);
assert(isfile(logsPath),     'Could not find cable_logs.csv at %s', logsPath);

% -------------------------------------------------------------------------
% Read CSV files ----------------------------------------------------------
netTbl   = readtable(networksPath,  'Delimiter', ',');
logsTbl  = readtable(logsPath,      'Delimiter', ',');

% Build a map: wire ID -> length string ----------------------------------
lenMap = containers.Map('KeyType','char','ValueType','char');
for k = 1:height(logsTbl)
    wire = strtrim(logsTbl.Cable{k});   % e.g. 'A00'
    len  = strtrim(logsTbl.Length{k});  % e.g. 4'
    if ~isempty(wire)
        lenMap(wire) = len;
    end
end

% -------------------------------------------------------------------------
% Iterate over each network and draw -------------------------------------
varNames = netTbl.Properties.VariableNames;
for n = 1:height(netTbl)
    try
        id  = netTbl{n, varNames{1}}{1};
    catch
        id  = sprintf('#%d', n);
    end
    netStr = netTbl{n, varNames{2}}{1};

    fprintf('Parsing network %s...\n', id);

    [nodeList, edgePairs, terminations] = parse_network_string(netStr);

    % Build node labels ---------------------------------------------------
    labels = cell(numel(nodeList), 1);
    for i = 1:numel(nodeList)
        wire = nodeList{i};
        % Length ----------------------------------------------------------
        if lenMap.isKey(wire)
            len = lenMap(wire);
        else
            len = '??';  % unknown length
        end
        % Termination -----------------------------------------------------
        if terminations.isKey(wire)
            t  = ['[' terminations(wire) ']'];
        else
            t  = '';
        end
        labels{i} = sprintf('%s\n%s %s', wire, len, t);
    end

    % Build digraph -------------------------------------------------------
    if isempty(edgePairs)           % isolated single-wire network
        G = digraph();
        G = addnode(G, nodeList(:));
    else
        src  = edgePairs(:,1);
        dst  = edgePairs(:,2);
        G    = digraph(src, dst, [], nodeList(:));
    end

    % Plot ---------------------------------------------------------------
    figure('Name', ['Network ' char(id)], 'NumberTitle', 'off');
    p = plot(G, 'Layout', 'layered', 'NodeLabel', labels, 'Interpreter', 'none');
    title(['Network ' char(id)]);
    p.NodeFontSize = 10;
    p.EdgeFontSize = 8;
end
end

% =========================================================================
function [nodes, edges, termMap] = parse_network_string(str)
% PARSE_NETWORK_STRING  Convert network definition into node/edge lists.
%   [nodes, edges, termMap] = parse_network_string(str)
%   * nodes   : 1×N cell array of unique wire IDs
%   * edges   : M×2 cell array, each row = {parent, child}
%   * termMap : containers.Map with termination code for leaf wires

str = regexprep(str, '\s', '');       % remove all whitespace

nodes = {};
edges = {};
termMap = containers.Map('KeyType','char','ValueType','char');
pos = 1;
len = numel(str);

    function [wire] = parseNode()
        %% Expect opening '{'
        if str(pos) ~= '{'
            error('Expected "{" at position %d in: %s', pos, str);
        end
        pos = pos + 1;   % consume '{'

        % ---- Read wire name --------------------------------------------
        start = pos;
        while pos <= len && ~ismember(str(pos), ['[', '{', '}', ' '])
            pos = pos + 1;
        end
        wire = str(start:pos-1);
        if isempty(wire)
            error('Empty wire name at position %d', pos);
        end
        if ~any(strcmp(nodes, wire))
            nodes{end+1} = wire; %#ok<AGROW>
        end

        % ---- Optional termination --------------------------------------
        if pos <= len && str(pos) == '['
            pos = pos + 1; % consume '['
            tStart = pos;
            while pos <= len && str(pos) ~= ']'
                pos = pos + 1;
            end
            if pos > len
                error('Unclosed termination bracket for wire %s', wire);
            end
            termCode = str(tStart:pos-1);
            termMap(wire) = termCode;
            pos = pos + 1; % consume ']'
        end

        % ---- Parse zero or more child branches -------------------------
        while pos <= len && str(pos) == '{'
            child = parseNode();
            edges(end+1, :) = {wire, child}; %#ok<AGROW>
        end

        % ---- Expect closing '}' ----------------------------------------
        if pos > len || str(pos) ~= '}'
            error('Expected "}" for wire %s (position %d)', wire, pos);
        end
        pos = pos + 1; % consume '}'
    end

% Kick-off parsing --------------------------------------------------------
parseNode();

% Verify full consumption -------------------------------------------------
if pos <= len
    remaining = str(pos:end);
    warning('Parser did not consume entire string. Remaining: %s', remaining);
end
end
