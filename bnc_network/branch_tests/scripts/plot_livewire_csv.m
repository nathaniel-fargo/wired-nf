% plot_livewire_csv.m
%
% Plots waveform data from a CSV file generated by convert_lws_csv.m.
% Can also save the plot to a file if an output path is provided.
%
% Author: Nathaniel Fargo
% Date: 2025-05-22 % Updated for batch processing
% Org: U of U WIRED
%
% Usage:
%   plot_livewire_csv('path/to/your_data.csv'); % Display plot
%   plot_livewire_csv('path/to/your_data.csv', {'48 MHz', '12 MHz'}); % Display specific freqs
%   plot_livewire_csv('path/to/your_data.csv', {}, 'path/to/output.png'); % Save plot with default freqs
%   plot_livewire_csv('path/to/your_data.csv', {'48 MHz'}, 'path/to/output.png'); % Save specific freq
%   plot_livewire_csv(..., ax_handle); % Plot to a given axes handle

function fig_handle = plot_livewire_csv(csvFilePath, specificFrequencies, outputFilePath, ax_handle)

    % Check for the minimum required input argument
    if nargin < 1
        error('Usage: plot_livewire_csv(csvFilePath, [specificFrequencies], [outputFilePath], [ax_handle])');
    end
    
    % Ensure the provided CSV file exists
    if ~exist(csvFilePath, 'file')
        error('CSV file not found: %s', csvFilePath);
    end

    % Set default for specificFrequencies if not provided (plot all)
    if nargin < 2
        specificFrequencies = {}; % Plot all frequencies by default
    end

    % Set default for outputFilePath if not provided (do not save)
    if nargin < 3
        outputFilePath = ''; % No output file path provided by default
    end
    if nargin < 4
        ax_handle = []; % Default to no axes handle
    end
    
    % Read the CSV file using detected import options
    try
        opts = detectImportOptions(csvFilePath);
        % Define columns that should always be treated as strings
        stringColumns = {'SerialNumber', 'SoftwareVersion', 'Date', 'Modulation', ...
                         'CableName', 'PreferredFrequency', 'Units', ...
                         'SelectedFrequencyAtAcquisition', 'MeasurementFrequency', 'DataType'};
        
        % Columns like UnitsPerSample, ZeroIndex, DistanceAtAcquisition might be numeric,
        % but can also contain non-numeric strings (e.g., "None").
        % Reading them as strings first allows for more robust parsing later.
        semi_numeric_cols = {'UnitsPerSample', 'ZeroIndex', 'DistanceAtAcquisition'};
        for i = 1:length(semi_numeric_cols)
            col_name = semi_numeric_cols{i};
            if any(strcmp(opts.VariableNames, col_name))
                % Read as string first for robust conversion or handling non-numeric like "None"
                opts = setvartype(opts, col_name, 'string'); 
            end
        end

        % Handle 'VOP' column if present (from older CSVs). It's not used for plotting
        % but needs to be read correctly if it exists.
        if any(strcmp(opts.VariableNames, 'VOP')) 
            if ~strcmp(opts.VariableTypes{strcmp(opts.VariableNames, 'VOP')}, 'double')
                opts = setvartype(opts, 'VOP', 'string'); 
            end
        end

        % Ensure all designated string columns are explicitly set to be read as strings.
        for k = 1:length(stringColumns)
            if any(strcmp(opts.VariableNames, stringColumns{k}))
                 % Ensure specified string columns are read as strings
                opts = setvartype(opts, stringColumns{k}, 'string');
            end
        end
        data = readtable(csvFilePath, opts);
    catch ME
        error('Failed to read CSV file: %s\n%s', csvFilePath, ME.message);
    end

    % Verify that all essential columns for plotting are present in the table.
    % VOP is no longer required for plotting itself.
    requiredCols = {'MeasurementFrequency', 'DataType', 'DataIndex', 'Value', 'SerialNumber', 'CableName', ...
                    'UnitsPerSample', 'Units', 'ZeroIndex', ...
                    'SelectedFrequencyAtAcquisition', 'DistanceAtAcquisition'}; % Added acq. cols
    if ~all(ismember(requiredCols, data.Properties.VariableNames))
        missing = setdiff(requiredCols, data.Properties.VariableNames);
        error('CSV file is missing required columns: %s', strjoin(missing, ', '));
    end

    % Filter the table to include only rows where DataType is "Waveform".
    waveformRows = strcmpi(data.DataType, "Waveform");
    waveformData = data(waveformRows, :);

    % If no waveform data exists after filtering, inform the user and exit.
    if isempty(waveformData)
        disp('No waveform data found in the CSV file.');
        if ~isempty(ax_handle) && isgraphics(ax_handle, 'axes')
            text(ax_handle, 0.5, 0.5, 'No waveform data found', 'HorizontalAlignment', 'center');
            fig_handle = get(ax_handle, 'Parent');
        else
            fig_handle = figure; % Create an empty figure to return
            text(0.5, 0.5, 'No waveform data found', 'HorizontalAlignment', 'center');
            if ~isempty(outputFilePath)
                saveas(fig_handle, outputFilePath);
                close(fig_handle);
            end
        end
        return;
    end

    % --- Get Global File Headers from the *original* data table or initial waveformData ---
    % These headers (e.g., SerialNumber, CableName) should be consistent for the entire file.
    % Use the very first row of the original CSV data to ensure these are truly global values.
    firstDataRow = data(1,:); 

    % Extract SerialNumber, handling potential missing or empty values.
    serialNumStr = 'Unknown Serial'; 
    if any(strcmp(firstDataRow.Properties.VariableNames, 'SerialNumber'))
        tempSerial = firstDataRow.SerialNumber;
        if ~(ismissing(tempSerial) || (isstring(tempSerial) && strlength(tempSerial)==0) || (ischar(tempSerial) && isempty(tempSerial)))
            serialNumStr = char(tempSerial);
        end
    end
    
    % Extract CableName, handling potential missing or empty values.
    cableNameStr = 'Unknown Cable'; 
    if any(strcmp(firstDataRow.Properties.VariableNames, 'CableName'))
        tempCable = firstDataRow.CableName;
        if ~(ismissing(tempCable) || (isstring(tempCable) && strlength(tempCable)==0) || (ischar(tempCable) && isempty(tempCable)))
            cableNameStr = char(tempCable);
        end
    end

    % Extract SelectedFrequencyAtAcquisition, handling "None" or empty values.
    % This frequency is used as a default for plotting if no specific frequencies are requested.
    acqFreqForPlotting = 'N/A'; 
    if any(strcmp(firstDataRow.Properties.VariableNames, 'SelectedFrequencyAtAcquisition'))
        tempAcqFreq = firstDataRow.SelectedFrequencyAtAcquisition;
        if ~(ismissing(tempAcqFreq) || (isstring(tempAcqFreq) && (tempAcqFreq == "" || strcmpi(tempAcqFreq, "None"))) || (ischar(tempAcqFreq) && (isempty(tempAcqFreq) || strcmpi(tempAcqFreq, 'None'))))
            acqFreqForPlotting = char(tempAcqFreq);
        end
    end

    % Define conversion factor from meters to feet.
    METERS_TO_FEET = 3.28084;

    % Extract DistanceAtAcquisition, convert to a numeric value in feet.
    % This involves checking the 'Units' column to correctly interpret the distance.
    numericAcqDistFeet = NaN; 
    if any(strcmp(firstDataRow.Properties.VariableNames, 'DistanceAtAcquisition'))
        tempAcqDistStr = firstDataRow.DistanceAtAcquisition; 
        
        % Determine the overall units (Standard/Metric) for interpreting DistanceAtAcquisition.
        overallUnitsStr = 'Standard'; 
        if any(strcmp(firstDataRow.Properties.VariableNames, 'Units'))
             tempOverallUnits = firstDataRow.Units;
             if ~(ismissing(tempOverallUnits) || (isstring(tempOverallUnits) && strlength(tempOverallUnits)==0) || (ischar(tempOverallUnits) && isempty(tempOverallUnits)))
                overallUnitsStr = char(tempOverallUnits);
             else
                warning('Overall units for DistanceAtAcquisition context is missing/empty. Assuming Standard (feet).');
             end
        else
            warning('Units column for DistanceAtAcquisition context not found. Assuming Standard (feet).');
        end
        isOverallMetric = strcmpi(overallUnitsStr, "Metric");

        % Convert the acquisition distance string to a number, handling "None" or non-numeric values.
        if ~(ismissing(tempAcqDistStr) || (isstring(tempAcqDistStr) && (tempAcqDistStr == "" || strcmpi(tempAcqDistStr, "None"))) || (ischar(tempAcqDistStr) && (isempty(tempAcqDistStr) || strcmpi(tempAcqDistStr, 'None'))))
            tempNumericAcqDist = str2double(char(tempAcqDistStr));
            if ~isnan(tempNumericAcqDist) % If conversion is successful
                if isOverallMetric
                    numericAcqDistFeet = tempNumericAcqDist * METERS_TO_FEET; % Convert if metric
                else
                    numericAcqDistFeet = tempNumericAcqDist; % Assume feet if standard
                end
            else
                 warning('DistanceAtAcquisition ''%s'' from file header is not a valid number.', char(tempAcqDistStr));
            end
        end
    end

    % Store a copy of all waveform data before any frequency-specific filtering.
    originalWaveformData = waveformData; 

    % Determine which frequencies to plot based on user input or defaults.
    if isempty(specificFrequencies) % No specific frequencies provided by the user.
        disp('No specific frequencies provided by user.');
        % Try to use the 'SelectedFrequencyAtAcquisition' from the file header.
        if ~strcmpi(acqFreqForPlotting, 'N/A')
            disp(['Attempting to plot SelectedFrequencyAtAcquisition: ' acqFreqForPlotting]);
            % Check if this acquisition frequency actually exists in the waveform data.
            freqExistsMask = strcmp(originalWaveformData.MeasurementFrequency, acqFreqForPlotting);
            if any(freqExistsMask)
                % If it exists, filter waveform data to only this frequency.
                waveformData = originalWaveformData(freqExistsMask, :); 
                frequenciesToPlot = {acqFreqForPlotting};
                disp(['Successfully selected data for: ' acqFreqForPlotting]);
            else
                % If acquisition frequency not found or has no data, plot all available frequencies.
                disp(['Warning: SelectedFrequencyAtAcquisition (' acqFreqForPlotting ') not found or has no waveform data. Plotting all available frequencies instead.']);
                waveformData = originalWaveformData; % Revert to all waveform data
                frequenciesToPlot = unique(waveformData.MeasurementFrequency, 'stable'); % Get all unique frequencies
            end
        else
            % If no valid acquisition frequency, plot all available waveform frequencies.
            disp('SelectedFrequencyAtAcquisition not available/invalid. Plotting all available waveform frequencies.');
            waveformData = originalWaveformData; % Use all waveform data
            frequenciesToPlot = unique(waveformData.MeasurementFrequency, 'stable'); % Get all unique frequencies
        end
    else % User has provided a list of specific frequencies.
        userSpecifiedFreqs = string(specificFrequencies(:)'); % Ensure it's a row string array
        % Filter the waveform data to include only the user-specified frequencies.
        validFreqMask = ismember(originalWaveformData.MeasurementFrequency, userSpecifiedFreqs);
        waveformData = originalWaveformData(validFreqMask, :);
        
        if isempty(waveformData)
            % If none of the user-specified frequencies are found or have data.
            disp('None of the user-specified frequencies were found or have waveform data.');
            frequenciesToPlot = {}; 
        else
            % Get the unique list of frequencies that will actually be plotted from the filtered data.
            frequenciesToPlot = unique(waveformData.MeasurementFrequency, 'stable');
        end
        
        % Report any user-specified frequencies that were not found in the data.
        foundInPlotData = unique(waveformData.MeasurementFrequency); 
        notFoundFreqs = setdiff(userSpecifiedFreqs, foundInPlotData);
        if ~isempty(notFoundFreqs)
            disp('Warning: The following user-specified frequencies were not found or had no waveform data after filtering:');
            disp(strjoin(notFoundFreqs, ', '));
        end
    end

    % If, after all filtering, there are no frequencies to plot, inform user and exit.
    if isempty(frequenciesToPlot)
        disp('No frequencies to plot after filtering.');
        if ~isempty(ax_handle) && isgraphics(ax_handle, 'axes')
            text(ax_handle, 0.5, 0.5, 'No frequencies to plot', 'HorizontalAlignment', 'center');
            fig_handle = get(ax_handle, 'Parent');
        else
            fig_handle = figure; % Create an empty figure to return
            text(0.5, 0.5, 'No frequencies to plot', 'HorizontalAlignment', 'center');
            if ~isempty(outputFilePath)
                saveas(fig_handle, outputFilePath);
                close(fig_handle);
            end
        end
        return;
    end

    % --- Figure and Axes Setup ---
    if ~isempty(ax_handle) && isgraphics(ax_handle, 'axes')
        % Use provided axes handle
        axes(ax_handle); % Make the provided axes current
        fig_handle = get(ax_handle, 'Parent');
        hold(ax_handle, 'on');
        
        % When plotting to a specific axis, simplify to plot only the first available frequency
        if ~isempty(frequenciesToPlot)
            frequenciesToPlot = frequenciesToPlot(1); 
            disp(['Plotting to provided axes. Using first available frequency: ', char(frequenciesToPlot(1))]);
        else
            text(ax_handle, 0.5, 0.5, 'No data for selected frequency', 'HorizontalAlignment', 'center');
            hold(ax_handle, 'off');
            return;
        end
        numPlots = 1;
        
    else
        % Original behavior: create a new figure
        fig_handle = figure;
        try 
            titleStr = sprintf('Waveforms for Serial: %s, Cable: %s', serialNumStr, cableNameStr);
            sgtitle(fig_handle, titleStr); % Set a super title for the entire figure.
        catch
            warning('sgtitle not available. Setting figure Name. May overlap.');
            set(fig_handle, 'Name', sprintf('S: %s, C: %s', serialNumStr, cableNameStr));
        end
        
        tlo = tiledlayout(fig_handle, 'flow', 'TileSpacing', 'compact', 'Padding', 'compact');
        numPlots = length(frequenciesToPlot);
    end

    % Loop through each frequency determined for plotting.
    for i = 1:numPlots
        currentFreq = frequenciesToPlot(i);
        % Filter data for the current frequency.
        freqDataRows = waveformData.MeasurementFrequency == currentFreq;
        freqData = waveformData(freqDataRows, :);
        
        % Handle cases where, despite earlier checks, no data remains for this specific frequency
        % (e.g., if specificFrequencies list was very restrictive leading to empty freqData here).
        if isempty(freqData)
            disp(['Skipping frequency ' char(currentFreq) ' as no data remains after filtering.']);
            nexttile(tlo); % Advance to the next tile
            
            % Prepare acquisition distance string for the "No Data" title
            acqDistStrPartForFiltered = 'Acq. Dist: N/A';
            if ~isnan(numericAcqDistFeet)
                feet = floor(numericAcqDistFeet);
                inches = round((numericAcqDistFeet - feet) * 12);
                if inches == 12 % Handle case where inches round up to 12
                    feet = feet + 1;
                    inches = 0;
                end
                acqDistStrPartForFiltered = sprintf('Acq. Dist: %d ft %d in', feet, inches);
            end
            % Set title for the empty plot
            titleStr = sprintf('%s (No Data - Filtered Out, %s)', char(currentFreq), acqDistStrPartForFiltered);
            title(titleStr);
            xlabel('Distance (ft)');
            ylabel('Normalized Value');
            text(0.5, 0.5, 'No Data', 'HorizontalAlignment', 'center', 'Units', 'normalized'); % Display "No Data" text
            xlim([0 10]); % Set default x-limits
            ylim([-1.1, 1.1]); % Set default y-limits for consistency
            grid on;
            continue; % Skip to the next frequency
        end

        % --- Y-axis Normalization ---
        % Normalize waveform values by dividing by the maximum absolute value in the current frequency's data.
        % This scales the waveform to a range of [-1, 1].
        y_values = freqData.Value;
        max_abs_y = max(abs(y_values));

        if max_abs_y == 0 % Avoid division by zero if all values are zero
            normalized_y_original = zeros(size(y_values));
        else
            normalized_y_original = y_values / max_abs_y;
        end

        % --- X-axis Distance in Feet ---
        % Calculate distance for each data point based on DataIndex and UnitsPerSample.
        dataIndex = freqData.DataIndex;
        
        % Convert UnitsPerSample to a numeric value, handling potential string format.
        currentUnitsPerSampleStr = freqData.UnitsPerSample(1); % Assume consistent for the frequency
        if isstring(currentUnitsPerSampleStr) || ischar(currentUnitsPerSampleStr)
            currentUnitsPerSample = str2double(currentUnitsPerSampleStr);
        else
            currentUnitsPerSample = currentUnitsPerSampleStr; % Already numeric
        end
        % Ensure UnitsPerSample is valid; default to 1.0 if not.
        if isnan(currentUnitsPerSample) || isempty(currentUnitsPerSample) || currentUnitsPerSample <= 0
            warning('Invalid or missing UnitsPerSample for frequency %s. Using 1.0.', char(currentFreq));
            currentUnitsPerSample = 1.0;
        end
        distance_original_units = dataIndex .* currentUnitsPerSample;

        % Determine if units are Metric or Standard (feet) for distance conversion.
        unitsStr = freqData.Units(1); % Assume consistent for the frequency
        if ismissing(unitsStr) || unitsStr == ""
            warning('Units (Standard/Metric) not found for frequency %s. Assuming Standard (feet).', char(currentFreq));
            unitsStr = "Standard"; % Default to Standard (feet)
        end
        isMetric = strcmpi(unitsStr, "Metric");
        
        % Convert distance to feet if originally in metric.
        distance_feet_original = distance_original_units;
        if isMetric 
            distance_feet_original = distance_original_units .* METERS_TO_FEET;
        end

        % --- Apply ZeroIndex Offset ---
        % The ZeroIndex indicates an offset to the start of the data.
        % Convert ZeroIndex to numeric, handling potential string format.
        currentZeroIndexStr = freqData.ZeroIndex(1); % Assume consistent for the frequency
        if isstring(currentZeroIndexStr) || ischar(currentZeroIndexStr)
            currentZeroIndex = str2double(currentZeroIndexStr);
        else
            currentZeroIndex = currentZeroIndexStr; % Assume already numeric
        end
        % Ensure ZeroIndex is valid; default to 0.0 if not.
        if isnan(currentZeroIndex) || isempty(currentZeroIndex)
            warning('Invalid or missing ZeroIndex for frequency %s. Using 0.0.', char(currentFreq));
            currentZeroIndex = 0.0;
        end

        % Calculate the zero offset in the original units and then convert to feet.
        zero_offset_original_units = currentZeroIndex * currentUnitsPerSample;
        zero_offset_feet = zero_offset_original_units;
        if isMetric
            zero_offset_feet = zero_offset_original_units * METERS_TO_FEET;
        end
        
        % Apply the zero offset to the distance data.
        distance_feet_shifted = distance_feet_original - zero_offset_feet;
        
        % Final data for plotting.
        x_data_to_plot = distance_feet_shifted;
        y_data_to_plot = normalized_y_original;

        % --- Plotting ---
        current_axes_to_plot_on = [];
        if ~isempty(ax_handle) && isgraphics(ax_handle, 'axes')
            current_axes_to_plot_on = ax_handle;
        else
            current_axes_to_plot_on = nexttile(tlo);
        end
        
        % --- Plot Title and Data (on current_axes_to_plot_on) ---
        baseTitlePart = char(currentFreq); % Frequency part of the title
        % Format acquisition distance for the title (e.g., "Acq. Dist: 10 ft 5 in").
        acqDistStrPart = 'Acq. Dist: N/A';
        if ~isnan(numericAcqDistFeet)
            feet = floor(numericAcqDistFeet);
            inches = round((numericAcqDistFeet - feet) * 12);
            if inches == 12 % Handle rounding of inches up to 12
                feet = feet + 1;
                inches = 0;
            end
            acqDistStrPart = sprintf('Acq. Dist: %d ft %d in', feet, inches);
        end

        % Plot the data if available.
        if ~isempty(x_data_to_plot) && ~isempty(y_data_to_plot) && numel(x_data_to_plot) > 0
            plot(current_axes_to_plot_on, x_data_to_plot, y_data_to_plot);
            hold(current_axes_to_plot_on, 'on'); 
            current_xlim = xlim(current_axes_to_plot_on); 
            
            if 0 >= current_xlim(1) && 0 <= current_xlim(2)
                line(current_axes_to_plot_on, [0 0], [-1.1, 1.1], 'Color', 'b', 'LineStyle', ':', 'LineWidth', 1, 'DisplayName', 'Zero Index');
            end
            
            if ~isnan(numericAcqDistFeet)
                % Note: The acquisition distance is an absolute point from the original file.
                % The plot's x-axis is *shifted* by the zero_offset_feet.
                % To plot acqDistLinePositionOnPlot correctly *relative to the shifted x-axis*,
                % we must plot it at (numericAcqDistFeet - zero_offset_feet) if the zero_offset_feet
                % has already been subtracted from x_data_to_plot.
                % However, the current x_data_to_plot *is* distance_feet_shifted.
                % numericAcqDistFeet is an absolute distance along the cable.
                % The x-axis of the plot *represents* these absolute positions, but shifted.
                % So, if the plot x-axis is `X_plot = X_absolute - zero_offset_feet`.
                % A line at `X_absolute = numericAcqDistFeet` should be drawn at `X_plot = numericAcqDistFeet - zero_offset_feet`.
                % This was not being done. Let's assume for now numericAcqDistFeet is intended to be plotted at its absolute value
                % on the *shifted* axis. This implies that `DistanceAtAcquisition` is meant to be interpreted
                % relative to the same origin as the shifted data.
                % Re-evaluating: The `x_data_to_plot` IS the `distance_feet_shifted`. So the x-axis *is* the shifted distance.
                % If `DistanceAtAcquisition` is a raw distance marker on the cable (e.g. 50ft from connector),
                % and the `ZeroIndex` shifts the plot so that `ZeroIndex * UPS` (e.g. 10ft) becomes `x=0`,
                % then the 50ft mark should appear at `x = 50ft - 10ft = 40ft` on the plot.
                % The code currently plots at `numericAcqDistFeet` directly on the `x_data_to_plot` axis.
                % This means it assumes `numericAcqDistFeet` is ALREADY relative to the zero-indexed start.
                % This might be the intended interpretation by the device generating the "DistanceAtAcquisition"
                % (i.e., it is the distance from the effective zero point after ZeroIndex is considered).
                % Given the existing code, we'll stick to plotting numericAcqDistFeet directly on the shifted axis.
                % The vertical line at 0 is the "Zero Index" line.
                % The vertical line at `numericAcqDistFeet` is the "Acq. Distance" line.
                % If `numericAcqDistFeet` is 50, and `zero_offset_feet` is 10, then
                % plot's x=0 is physical 10ft. plot's x=40 is physical 50ft.
                % So, the line should be at `numericAcqDistFeet - zero_offset_feet` on the plot.
                % Let's test this assumption. If DistanceAtAcquisition is 0, and ZeroIndex is 0, line at 0. OK.
                % If DistanceAtAcquisition is 10, ZeroIndex is 0, line at 10. OK.
                % If DistanceAtAcquisition is 10, ZeroIndex is 5 (UPS=1), zero_offset_feet=5.
                %   x_data_to_plot starts from -5. Line for Acq.Dist should be at 10-5 = 5 on the plot.
                % The current code plots `numericAcqDistFeet` directly.
                % This seems to be what was intended by "Acquisition Distance" label next to it.
                % Let's keep it, but add a comment about this interpretation.
                acqDistLinePositionOnPlot = numericAcqDistFeet; % This is plotted directly on the shifted x-axis.
                                                             % This implies DistanceAtAcquisition is meant to be interpreted
                                                             % relative to the same origin as the shifted data.
                if acqDistLinePositionOnPlot >= current_xlim(1) && acqDistLinePositionOnPlot <= current_xlim(2)
                    line(current_axes_to_plot_on, [acqDistLinePositionOnPlot acqDistLinePositionOnPlot], [-1.1, 1.1], 'Color', 'b', 'LineStyle', ':', 'LineWidth', 1, 'DisplayName', 'Acq. Distance');
                end
            end
            hold(current_axes_to_plot_on, 'off'); % Release the plot

            plotTitleStr = sprintf('%s (%s)', baseTitlePart, acqDistStrPart);
            axis(current_axes_to_plot_on, 'tight');

        else 
            disp(['Data for frequency ' char(currentFreq) ' is empty or invalid for plotting after processing.']);
            plotTitleStr = sprintf('%s (No Data, %s)', baseTitlePart, acqDistStrPart);
            plot(current_axes_to_plot_on, NaN, NaN); 
            text(current_axes_to_plot_on, 0.5, 0.5, 'No Data', 'HorizontalAlignment', 'center', 'Units', 'normalized'); 
            xlim(current_axes_to_plot_on, [0 10]); 
            
            current_xlim_no_data = xlim(current_axes_to_plot_on);
            if 0 >= current_xlim_no_data(1) && 0 <= current_xlim_no_data(2) 
                line(current_axes_to_plot_on, [0 0], [-1.1, 1.1], 'Color', 'b', 'LineStyle', ':', 'LineWidth', 1);
            end
            if ~isnan(numericAcqDistFeet) && numericAcqDistFeet >= current_xlim_no_data(1) && numericAcqDistFeet <= current_xlim_no_data(2) 
                line(current_axes_to_plot_on, [numericAcqDistFeet numericAcqDistFeet], [-1.1, 1.1], 'Color', 'b', 'LineStyle', ':', 'LineWidth', 1);
            end
        end
        
        title(current_axes_to_plot_on, plotTitleStr); 
        xlabel(current_axes_to_plot_on, 'Distance (ft)');
        ylabel(current_axes_to_plot_on, 'Normalized Value');
        ylim(current_axes_to_plot_on, [-1.1, 1.1]); 
        grid(current_axes_to_plot_on, 'on'); 

    end
    
    if ~isempty(ax_handle) && isgraphics(ax_handle, 'axes')
        hold(ax_handle, 'off'); % Ensure hold is off for the provided axes
    end

    % Display messages if no plots were generated.
    if numPlots == 0 && ~isempty(specificFrequencies)
        disp('No data plotted. Ensure specified frequencies exist and have waveform data.')
    elseif numPlots == 0
        disp('No waveform data found to plot.')
    end

    % Save the figure to a file if an outputFilePath was provided.
    if ~isempty(outputFilePath)
        try
            % Set PaperPositionMode to 'auto' for better sizing in the saved file,
            % or explicitly set figure position/size for consistent output.
            set(fig_handle, 'PaperPositionMode', 'auto'); 
            % Example of explicit sizing:
            % set(fig_handle, 'Position', [100, 100, 1024, 768]); % X, Y, Width, Height
            
            saveas(fig_handle, outputFilePath);
            fprintf('Plot saved to %s\n', outputFilePath);
            if isempty(ax_handle) % Only close if we created the figure
                close(fig_handle); 
            end
        catch ME_save
            warning('Failed to save plot to %s: %s', outputFilePath, ME_save.message);
            if isempty(ax_handle) && ishandle(fig_handle) % Only close if we created the figure
                close(fig_handle); 
            end
        end
    else
        % If not saving to file, and not plotting to a given ax_handle, the figure will remain open.
        % If an ax_handle was given, the caller manages the figure's visibility.
    end

end
