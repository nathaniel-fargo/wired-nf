% plot_smooth_livewire.m
%
% Plots smoothed waveform data from a CSV file generated by convert_lws_csv.m.
% Uses FFT-based interpolation with zero padding to create smooth curves.
% Can also save the plot to a file if an output path is provided.
%
% Author: Nathaniel Fargo
% Date: 2025-01-27
% Org: U of U WIRED
%
% Usage:
%   plot_smooth_livewire('path/to/your_data.csv'); % Display smooth plot
%   plot_smooth_livewire('path/to/your_data.csv', {'48 MHz', '12 MHz'}); % Display specific freqs
%   plot_smooth_livewire('path/to/your_data.csv', {}, 'path/to/output.png'); % Save plot with default freqs
%   plot_smooth_livewire('path/to/your_data.csv', {'48 MHz'}, 'path/to/output.png'); % Save specific freq
%   plot_smooth_livewire(..., ax_handle); % Plot to a given axes handle
%   plot_smooth_livewire(..., ax_handle, interpolation_factor); % Custom interpolation factor (default: 4)

function fig_handle = plot_smooth_livewire(csvFilePath, specificFrequencies, outputFilePath, ax_handle, interpolation_factor)

    % Check for the minimum required input argument
    if nargin < 1
        error('Usage: plot_smooth_livewire(csvFilePath, [specificFrequencies], [outputFilePath], [ax_handle], [interpolation_factor])');
    end
    
    % Ensure the provided CSV file exists
    if ~exist(csvFilePath, 'file')
        error('CSV file not found: %s', csvFilePath);
    end

    % Set default for specificFrequencies if not provided (plot all)
    if nargin < 2
        specificFrequencies = {}; % Plot all frequencies by default
    end

    % Set default for outputFilePath if not provided (do not save)
    if nargin < 3
        outputFilePath = ''; % No output file path provided by default
    end
    if nargin < 4
        ax_handle = []; % Default to no axes handle
    end
    if nargin < 5
        interpolation_factor = 4; % Default interpolation factor
    end
    
    % Read the CSV file using detected import options (same as plot_livewire_csv.m)
    try
        opts = detectImportOptions(csvFilePath);
        % Define columns that should always be treated as strings
        stringColumns = {'SerialNumber', 'SoftwareVersion', 'Date', 'Modulation', ...
                         'CableName', 'PreferredFrequency', 'Units', ...
                         'SelectedFrequencyAtAcquisition', 'MeasurementFrequency', 'DataType'};
        
        % Columns like UnitsPerSample, ZeroIndex, DistanceAtAcquisition might be numeric,
        % but can also contain non-numeric strings (e.g., "None").
        semi_numeric_cols = {'UnitsPerSample', 'ZeroIndex', 'DistanceAtAcquisition'};
        for i = 1:length(semi_numeric_cols)
            col_name = semi_numeric_cols{i};
            if any(strcmp(opts.VariableNames, col_name))
                opts = setvartype(opts, col_name, 'string'); 
            end
        end

        % Handle 'VOP' column if present
        if any(strcmp(opts.VariableNames, 'VOP')) 
            if ~strcmp(opts.VariableTypes{strcmp(opts.VariableNames, 'VOP')}, 'double')
                opts = setvartype(opts, 'VOP', 'string'); 
            end
        end

        % Ensure all designated string columns are explicitly set to be read as strings
        for k = 1:length(stringColumns)
            if any(strcmp(opts.VariableNames, stringColumns{k}))
                opts = setvartype(opts, stringColumns{k}, 'string');
            end
        end
        data = readtable(csvFilePath, opts);
    catch ME
        error('Failed to read CSV file: %s\n%s', csvFilePath, ME.message);
    end

    % Verify that all essential columns for plotting are present
    requiredCols = {'MeasurementFrequency', 'DataType', 'DataIndex', 'Value', 'SerialNumber', 'CableName', ...
                    'UnitsPerSample', 'Units', 'ZeroIndex', ...
                    'SelectedFrequencyAtAcquisition', 'DistanceAtAcquisition'};
    if ~all(ismember(requiredCols, data.Properties.VariableNames))
        missing = setdiff(requiredCols, data.Properties.VariableNames);
        error('CSV file is missing required columns: %s', strjoin(missing, ', '));
    end

    % Filter the table to include only rows where DataType is "Waveform"
    waveformRows = strcmpi(data.DataType, "Waveform");
    waveformData = data(waveformRows, :);

    % If no waveform data exists after filtering, inform the user and exit
    if isempty(waveformData)
        disp('No waveform data found in the CSV file.');
        if ~isempty(ax_handle) && isgraphics(ax_handle, 'axes')
            text(ax_handle, 0.5, 0.5, 'No waveform data found', 'HorizontalAlignment', 'center');
            fig_handle = get(ax_handle, 'Parent');
        else
            fig_handle = figure;
            text(0.5, 0.5, 'No waveform data found', 'HorizontalAlignment', 'center');
            if ~isempty(outputFilePath)
                saveas(fig_handle, outputFilePath);
                close(fig_handle);
            end
        end
        return;
    end

    % Extract global file headers (same logic as plot_livewire_csv.m)
    firstDataRow = data(1,:); 

    % Extract SerialNumber
    serialNumStr = 'Unknown Serial'; 
    if any(strcmp(firstDataRow.Properties.VariableNames, 'SerialNumber'))
        tempSerial = firstDataRow.SerialNumber;
        if ~(ismissing(tempSerial) || (isstring(tempSerial) && strlength(tempSerial)==0) || (ischar(tempSerial) && isempty(tempSerial)))
            serialNumStr = char(tempSerial);
        end
    end
    
    % Extract CableName
    cableNameStr = 'Unknown Cable'; 
    if any(strcmp(firstDataRow.Properties.VariableNames, 'CableName'))
        tempCable = firstDataRow.CableName;
        if ~(ismissing(tempCable) || (isstring(tempCable) && strlength(tempCable)==0) || (ischar(tempCable) && isempty(tempCable)))
            cableNameStr = char(tempCable);
        end
    end

    % Extract SelectedFrequencyAtAcquisition
    acqFreqForPlotting = 'N/A'; 
    if any(strcmp(firstDataRow.Properties.VariableNames, 'SelectedFrequencyAtAcquisition'))
        tempAcqFreq = firstDataRow.SelectedFrequencyAtAcquisition;
        if ~(ismissing(tempAcqFreq) || (isstring(tempAcqFreq) && (tempAcqFreq == "" || strcmpi(tempAcqFreq, "None"))) || (ischar(tempAcqFreq) && (isempty(tempAcqFreq) || strcmpi(tempAcqFreq, 'None'))))
            acqFreqForPlotting = char(tempAcqFreq);
        end
    end

    % Define conversion factor from meters to feet
    METERS_TO_FEET = 3.28084;

    % Extract DistanceAtAcquisition
    numericAcqDistFeet = NaN; 
    if any(strcmp(firstDataRow.Properties.VariableNames, 'DistanceAtAcquisition'))
        tempAcqDistStr = firstDataRow.DistanceAtAcquisition; 
        
        % Determine the overall units
        overallUnitsStr = 'Standard'; 
        if any(strcmp(firstDataRow.Properties.VariableNames, 'Units'))
             tempOverallUnits = firstDataRow.Units;
             if ~(ismissing(tempOverallUnits) || (isstring(tempOverallUnits) && strlength(tempOverallUnits)==0) || (ischar(tempOverallUnits) && isempty(tempOverallUnits)))
                overallUnitsStr = char(tempOverallUnits);
             else
                warning('Overall units for DistanceAtAcquisition context is missing/empty. Assuming Standard (feet).');
             end
        else
            warning('Units column for DistanceAtAcquisition context not found. Assuming Standard (feet).');
        end
        isOverallMetric = strcmpi(overallUnitsStr, "Metric");

        % Convert the acquisition distance string to a number
        if ~(ismissing(tempAcqDistStr) || (isstring(tempAcqDistStr) && (tempAcqDistStr == "" || strcmpi(tempAcqDistStr, "None"))) || (ischar(tempAcqDistStr) && (isempty(tempAcqDistStr) || strcmpi(tempAcqDistStr, 'None'))))
            tempNumericAcqDist = str2double(char(tempAcqDistStr));
            if ~isnan(tempNumericAcqDist)
                if isOverallMetric
                    numericAcqDistFeet = tempNumericAcqDist * METERS_TO_FEET;
                else
                    numericAcqDistFeet = tempNumericAcqDist;
                end
            else
                 warning('DistanceAtAcquisition ''%s'' from file header is not a valid number.', char(tempAcqDistStr));
            end
        end
    end

    % Store a copy of all waveform data before any frequency-specific filtering
    originalWaveformData = waveformData; 

    % Determine which frequencies to plot (same logic as plot_livewire_csv.m)
    if isempty(specificFrequencies)
        disp('No specific frequencies provided by user.');
        if ~strcmpi(acqFreqForPlotting, 'N/A')
            disp(['Attempting to plot SelectedFrequencyAtAcquisition: ' acqFreqForPlotting]);
            freqExistsMask = strcmp(originalWaveformData.MeasurementFrequency, acqFreqForPlotting);
            if any(freqExistsMask)
                waveformData = originalWaveformData(freqExistsMask, :); 
                frequenciesToPlot = {acqFreqForPlotting};
                disp(['Successfully selected data for: ' acqFreqForPlotting]);
            else
                disp(['Warning: SelectedFrequencyAtAcquisition (' acqFreqForPlotting ') not found or has no waveform data. Plotting all available frequencies instead.']);
                waveformData = originalWaveformData;
                frequenciesToPlot = unique(waveformData.MeasurementFrequency, 'stable');
            end
        else
            disp('SelectedFrequencyAtAcquisition not available/invalid. Plotting all available waveform frequencies.');
            waveformData = originalWaveformData;
            frequenciesToPlot = unique(waveformData.MeasurementFrequency, 'stable');
        end
    else
        userSpecifiedFreqs = string(specificFrequencies(:)');
        validFreqMask = ismember(originalWaveformData.MeasurementFrequency, userSpecifiedFreqs);
        waveformData = originalWaveformData(validFreqMask, :);
        
        if isempty(waveformData)
            disp('None of the user-specified frequencies were found or have waveform data.');
            frequenciesToPlot = {}; 
        else
            frequenciesToPlot = unique(waveformData.MeasurementFrequency, 'stable');
        end
        
        foundInPlotData = unique(waveformData.MeasurementFrequency); 
        notFoundFreqs = setdiff(userSpecifiedFreqs, foundInPlotData);
        if ~isempty(notFoundFreqs)
            disp('Warning: The following user-specified frequencies were not found or had no waveform data after filtering:');
            disp(strjoin(notFoundFreqs, ', '));
        end
    end

    % If no frequencies to plot, exit
    if isempty(frequenciesToPlot)
        disp('No frequencies to plot after filtering.');
        if ~isempty(ax_handle) && isgraphics(ax_handle, 'axes')
            text(ax_handle, 0.5, 0.5, 'No frequencies to plot', 'HorizontalAlignment', 'center');
            fig_handle = get(ax_handle, 'Parent');
        else
            fig_handle = figure;
            text(0.5, 0.5, 'No frequencies to plot', 'HorizontalAlignment', 'center');
            if ~isempty(outputFilePath)
                saveas(fig_handle, outputFilePath);
                close(fig_handle);
            end
        end
        return;
    end

    % Figure and Axes Setup
    if ~isempty(ax_handle) && isgraphics(ax_handle, 'axes')
        axes(ax_handle);
        fig_handle = get(ax_handle, 'Parent');
        hold(ax_handle, 'on');
        
        if ~isempty(frequenciesToPlot)
            frequenciesToPlot = frequenciesToPlot(1); 
            disp(['Plotting to provided axes. Using first available frequency: ', char(frequenciesToPlot(1))]);
        else
            text(ax_handle, 0.5, 0.5, 'No data for selected frequency', 'HorizontalAlignment', 'center');
            hold(ax_handle, 'off');
            return;
        end
        numPlots = 1;
        
    else
        fig_handle = figure;
        try 
            titleStr = sprintf('Smoothed Waveforms for Serial: %s, Cable: %s', serialNumStr, cableNameStr);
            sgtitle(fig_handle, titleStr);
        catch
            warning('sgtitle not available. Setting figure Name. May overlap.');
            set(fig_handle, 'Name', sprintf('Smooth S: %s, C: %s', serialNumStr, cableNameStr));
        end
        
        tlo = tiledlayout(fig_handle, 'flow', 'TileSpacing', 'compact', 'Padding', 'compact');
        numPlots = length(frequenciesToPlot);
    end

    % Loop through each frequency for plotting
    for i = 1:numPlots
        currentFreq = frequenciesToPlot(i);
        freqDataRows = waveformData.MeasurementFrequency == currentFreq;
        freqData = waveformData(freqDataRows, :);
        
        if isempty(freqData)
            disp(['Skipping frequency ' char(currentFreq) ' as no data remains after filtering.']);
            if ~isempty(ax_handle) && isgraphics(ax_handle, 'axes')
                current_axes_to_plot_on = ax_handle;
            else
                current_axes_to_plot_on = nexttile(tlo);
            end
            
            acqDistStrPartForFiltered = 'Acq. Dist: N/A';
            if ~isnan(numericAcqDistFeet)
                feet = floor(numericAcqDistFeet);
                inches = round((numericAcqDistFeet - feet) * 12);
                if inches == 12
                    feet = feet + 1;
                    inches = 0;
                end
                acqDistStrPartForFiltered = sprintf('Acq. Dist: %d ft %d in', feet, inches);
            end
            titleStr = sprintf('%s (No Data - Filtered Out, %s)', char(currentFreq), acqDistStrPartForFiltered);
            title(current_axes_to_plot_on, titleStr);
            xlabel(current_axes_to_plot_on, 'Distance (ft)');
            ylabel(current_axes_to_plot_on, 'Normalized Value');
            text(current_axes_to_plot_on, 0.5, 0.5, 'No Data', 'HorizontalAlignment', 'center', 'Units', 'normalized');
            xlim(current_axes_to_plot_on, [0 10]);
            ylim(current_axes_to_plot_on, [-1.1, 1.1]);
            grid(current_axes_to_plot_on, 'on');
            continue;
        end

        % Process data (same as plot_livewire_csv.m)
        y_values = freqData.Value;
        max_abs_y = max(abs(y_values));

        if max_abs_y == 0
            normalized_y_original = zeros(size(y_values));
        else
            normalized_y_original = y_values / max_abs_y;
        end

        % Calculate distance data
        dataIndex = freqData.DataIndex;
        
        currentUnitsPerSampleStr = freqData.UnitsPerSample(1);
        if isstring(currentUnitsPerSampleStr) || ischar(currentUnitsPerSampleStr)
            currentUnitsPerSample = str2double(currentUnitsPerSampleStr);
        else
            currentUnitsPerSample = currentUnitsPerSampleStr;
        end
        if isnan(currentUnitsPerSample) || isempty(currentUnitsPerSample) || currentUnitsPerSample <= 0
            warning('Invalid or missing UnitsPerSample for frequency %s. Using 1.0.', char(currentFreq));
            currentUnitsPerSample = 1.0;
        end
        distance_original_units = dataIndex .* currentUnitsPerSample;

        unitsStr = freqData.Units(1);
        if ismissing(unitsStr) || unitsStr == ""
            warning('Units (Standard/Metric) not found for frequency %s. Assuming Standard (feet).', char(currentFreq));
            unitsStr = "Standard";
        end
        isMetric = strcmpi(unitsStr, "Metric");
        
        distance_feet_original = distance_original_units;
        if isMetric 
            distance_feet_original = distance_original_units .* METERS_TO_FEET;
        end

        % Apply ZeroIndex Offset
        currentZeroIndexStr = freqData.ZeroIndex(1);
        if isstring(currentZeroIndexStr) || ischar(currentZeroIndexStr)
            currentZeroIndex = str2double(currentZeroIndexStr);
        else
            currentZeroIndex = currentZeroIndexStr;
        end
        if isnan(currentZeroIndex) || isempty(currentZeroIndex)
            warning('Invalid or missing ZeroIndex for frequency %s. Using 0.0.', char(currentFreq));
            currentZeroIndex = 0.0;
        end

        zero_offset_original_units = currentZeroIndex * currentUnitsPerSample;
        zero_offset_feet = zero_offset_original_units;
        if isMetric
            zero_offset_feet = zero_offset_original_units * METERS_TO_FEET;
        end
        
        distance_feet_shifted = distance_feet_original - zero_offset_feet;
        
        % Original data for reference
        x_data_original = distance_feet_shifted;
        y_data_original = normalized_y_original;

        % ===== FFT-BASED INTERPOLATION =====
        % Sort data by distance to ensure proper ordering
        [x_sorted, sort_idx] = sort(x_data_original);
        y_sorted = y_data_original(sort_idx);
        
        % Remove any duplicate x values by averaging y values
        [x_unique, ~, idx] = unique(x_sorted);
        y_unique = accumarray(idx, y_sorted, [], @mean);
        
        % Create evenly spaced grid for interpolation
        N_original = length(x_unique);
        if N_original < 4
            warning('Not enough data points for FFT interpolation. Using original data.');
            x_data_to_plot = x_unique;
            y_data_to_plot = y_unique;
        else
            % Interpolate to evenly spaced grid first
            x_min = min(x_unique);
            x_max = max(x_unique);
            x_even = linspace(x_min, x_max, N_original);
            y_even = interp1(x_unique, y_unique, x_even, 'linear', 'extrap');
            
            % Apply FFT-based interpolation with zero padding
            Y_fft = fft(y_even);
            N_new = N_original * interpolation_factor;
            
            % Zero pad in frequency domain
            Y_padded = zeros(1, N_new);
            half_N = floor(N_original/2);
            
            % Copy positive frequencies
            Y_padded(1:half_N+1) = Y_fft(1:half_N+1);
            
            % Copy negative frequencies
            if mod(N_original, 2) == 0
                % Even length: handle Nyquist frequency
                Y_padded(N_new-half_N+2:N_new) = Y_fft(half_N+2:N_original);
            else
                % Odd length
                Y_padded(N_new-half_N+1:N_new) = Y_fft(half_N+2:N_original);
            end
            
            % Scale to maintain energy
            Y_padded = Y_padded * interpolation_factor;
            
            % Inverse FFT to get interpolated signal
            y_smooth = real(ifft(Y_padded));
            
            % Create corresponding x values
            x_smooth = linspace(x_min, x_max, N_new);
            
            x_data_to_plot = x_smooth;
            y_data_to_plot = y_smooth;
        end

        % Plotting
        if ~isempty(ax_handle) && isgraphics(ax_handle, 'axes')
            current_axes_to_plot_on = ax_handle;
        else
            current_axes_to_plot_on = nexttile(tlo);
        end
        
        % Plot title formatting
        baseTitlePart = char(currentFreq);
        acqDistStrPart = 'Acq. Dist: N/A';
        if ~isnan(numericAcqDistFeet)
            feet = floor(numericAcqDistFeet);
            inches = round((numericAcqDistFeet - feet) * 12);
            if inches == 12
                feet = feet + 1;
                inches = 0;
            end
            acqDistStrPart = sprintf('Acq. Dist: %d ft %d in', feet, inches);
        end

        % Plot the smoothed data
        if ~isempty(x_data_to_plot) && ~isempty(y_data_to_plot) && numel(x_data_to_plot) > 0
            % Plot original data as points
            plot(current_axes_to_plot_on, x_data_original, y_data_original, 'o', 'MarkerSize', 3, 'Color', [0.7 0.7 0.7], 'DisplayName', 'Original');
            hold(current_axes_to_plot_on, 'on');
            
            % Plot smoothed data as line
            plot(current_axes_to_plot_on, x_data_to_plot, y_data_to_plot, 'b-', 'LineWidth', 1.5, 'DisplayName', 'Smoothed');
            
            current_xlim = xlim(current_axes_to_plot_on); 
            
            % Add reference lines
            if 0 >= current_xlim(1) && 0 <= current_xlim(2)
                line(current_axes_to_plot_on, [0 0], [-1.1, 1.1], 'Color', 'r', 'LineStyle', ':', 'LineWidth', 1, 'DisplayName', 'Zero Index');
            end
            
            if ~isnan(numericAcqDistFeet)
                acqDistLinePositionOnPlot = numericAcqDistFeet;
                if acqDistLinePositionOnPlot >= current_xlim(1) && acqDistLinePositionOnPlot <= current_xlim(2)
                    line(current_axes_to_plot_on, [acqDistLinePositionOnPlot acqDistLinePositionOnPlot], [-1.1, 1.1], 'Color', 'g', 'LineStyle', ':', 'LineWidth', 1, 'DisplayName', 'Acq. Distance');
                end
            end
            
            hold(current_axes_to_plot_on, 'off');

            plotTitleStr = sprintf('%s (Smoothed, %s)', baseTitlePart, acqDistStrPart);
            axis(current_axes_to_plot_on, 'tight');

        else 
            disp(['Data for frequency ' char(currentFreq) ' is empty or invalid for plotting after processing.']);
            plotTitleStr = sprintf('%s (No Data, %s)', baseTitlePart, acqDistStrPart);
            plot(current_axes_to_plot_on, NaN, NaN); 
            text(current_axes_to_plot_on, 0.5, 0.5, 'No Data', 'HorizontalAlignment', 'center', 'Units', 'normalized'); 
            xlim(current_axes_to_plot_on, [0 10]); 
            
            current_xlim_no_data = xlim(current_axes_to_plot_on);
            if 0 >= current_xlim_no_data(1) && 0 <= current_xlim_no_data(2) 
                line(current_axes_to_plot_on, [0 0], [-1.1, 1.1], 'Color', 'r', 'LineStyle', ':', 'LineWidth', 1);
            end
            if ~isnan(numericAcqDistFeet) && numericAcqDistFeet >= current_xlim_no_data(1) && numericAcqDistFeet <= current_xlim_no_data(2) 
                line(current_axes_to_plot_on, [numericAcqDistFeet numericAcqDistFeet], [-1.1, 1.1], 'Color', 'g', 'LineStyle', ':', 'LineWidth', 1);
            end
        end
        
        title(current_axes_to_plot_on, plotTitleStr); 
        xlabel(current_axes_to_plot_on, 'Distance (ft)');
        ylabel(current_axes_to_plot_on, 'Normalized Value');
        ylim(current_axes_to_plot_on, [-1.1, 1.1]); 
        grid(current_axes_to_plot_on, 'on'); 
        
        % Add legend if not plotting to external axes
        if isempty(ax_handle)
            legend(current_axes_to_plot_on, 'Location', 'best');
        end

    end
    
    if ~isempty(ax_handle) && isgraphics(ax_handle, 'axes')
        hold(ax_handle, 'off');
    end

    % Display messages if no plots were generated
    if numPlots == 0 && ~isempty(specificFrequencies)
        disp('No data plotted. Ensure specified frequencies exist and have waveform data.')
    elseif numPlots == 0
        disp('No waveform data found to plot.')
    end

    % Save the figure to a file if an outputFilePath was provided
    if ~isempty(outputFilePath)
        try
            set(fig_handle, 'PaperPositionMode', 'auto'); 
            saveas(fig_handle, outputFilePath);
            fprintf('Smoothed plot saved to %s\n', outputFilePath);
            if isempty(ax_handle)
                close(fig_handle); 
            end
        catch ME_save
            warning('Failed to save plot to %s: %s', outputFilePath, ME_save.message);
            if isempty(ax_handle) && ishandle(fig_handle)
                close(fig_handle); 
            end
        end
    end

end
