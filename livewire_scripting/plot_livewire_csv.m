% plot_livewire_csv.m
%
% Plots waveform data from a CSV file generated by convert_lws_csv.m.
%
% Author: Nathaniel Fargo
% Date: 2025-05-21
% Org: U of U WIRED
%
% Usage:
%   plot_livewire_csv('path/to/your_data.csv');
%   plot_livewire_csv('path/to/your_data.csv', {'48 MHz', '12 MHz'});

function plot_livewire_csv(csvFilePath, specificFrequencies)

    if nargin < 1
        error('Usage: plot_livewire_csv(csvFilePath, [specificFrequencies])');
    end
    
    if ~exist(csvFilePath, 'file')
        error('CSV file not found: %s', csvFilePath);
    end

    if nargin < 2
        specificFrequencies = {}; % Plot all frequencies by default
    end
    
    % Read the CSV file
    try
        opts = detectImportOptions(csvFilePath);
        stringColumns = {'SerialNumber', 'SoftwareVersion', 'Date', 'Modulation', ...
                         'CableName', 'PreferredFrequency', 'Units', ...
                         'SelectedFrequencyAtAcquisition', 'MeasurementFrequency', 'DataType'};
        
        % Handle UnitsPerSample and ZeroIndex, which might be numeric or string
        % Also SelectedFrequencyAtAcquisition, DistanceAtAcquisition which might be strings like "None"
        semi_numeric_cols = {'UnitsPerSample', 'ZeroIndex', 'DistanceAtAcquisition'};
        for i = 1:length(semi_numeric_cols)
            col_name = semi_numeric_cols{i};
            if any(strcmp(opts.VariableNames, col_name))
                % Read as string first for robust conversion or handling non-numeric like "None"
                opts = setvartype(opts, col_name, 'string'); 
            end
        end

        % VOP might still be in older CSVs, ensure it's handled during import if present, though not used for plotting
        if any(strcmp(opts.VariableNames, 'VOP')) 
            if ~strcmp(opts.VariableTypes{strcmp(opts.VariableNames, 'VOP')}, 'double')
                opts = setvartype(opts, 'VOP', 'string'); 
            end
        end

        for k = 1:length(stringColumns)
            if any(strcmp(opts.VariableNames, stringColumns{k}))
                 % Ensure specified string columns are read as strings
                opts = setvartype(opts, stringColumns{k}, 'string');
            end
        end
        data = readtable(csvFilePath, opts);
    catch ME
        error('Failed to read CSV file: %s\n%s', csvFilePath, ME.message);
    end

    % Check for required columns (VOP no longer required for plotting)
    requiredCols = {'MeasurementFrequency', 'DataType', 'DataIndex', 'Value', 'SerialNumber', 'CableName', ...
                    'UnitsPerSample', 'Units', 'ZeroIndex', ...
                    'SelectedFrequencyAtAcquisition', 'DistanceAtAcquisition'}; % Added acq. cols
    if ~all(ismember(requiredCols, data.Properties.VariableNames))
        missing = setdiff(requiredCols, data.Properties.VariableNames);
        error('CSV file is missing required columns: %s', strjoin(missing, ', '));
    end

    % Filter for Waveform data only
    waveformRows = strcmpi(data.DataType, "Waveform");
    waveformData = data(waveformRows, :);

    if isempty(waveformData)
        disp('No waveform data found in the CSV file.');
        return;
    end

    % --- Get Global File Headers from the *original* data table or initial waveformData ---
    % These should be consistent across the file.
    
    % Use the overall 'data' table for SerialNumber and CableName to avoid issues if waveformData is empty initially.
    firstDataRow = data(1,:); % Use the very first row of the CSV for truly global headers

    serialNumStr = 'Unknown Serial'; 
    if any(strcmp(firstDataRow.Properties.VariableNames, 'SerialNumber'))
        tempSerial = firstDataRow.SerialNumber;
        if ~(ismissing(tempSerial) || (isstring(tempSerial) && strlength(tempSerial)==0) || (ischar(tempSerial) && isempty(tempSerial)))
            serialNumStr = char(tempSerial);
        end
    end
    
    cableNameStr = 'Unknown Cable'; 
    if any(strcmp(firstDataRow.Properties.VariableNames, 'CableName'))
        tempCable = firstDataRow.CableName;
        if ~(ismissing(tempCable) || (isstring(tempCable) && strlength(tempCable)==0) || (ischar(tempCable) && isempty(tempCable)))
            cableNameStr = char(tempCable);
        end
    end

    acqFreqForPlotting = 'N/A'; 
    if any(strcmp(firstDataRow.Properties.VariableNames, 'SelectedFrequencyAtAcquisition'))
        tempAcqFreq = firstDataRow.SelectedFrequencyAtAcquisition;
        if ~(ismissing(tempAcqFreq) || (isstring(tempAcqFreq) && (tempAcqFreq == "" || strcmpi(tempAcqFreq, "None"))) || (ischar(tempAcqFreq) && (isempty(tempAcqFreq) || strcmpi(tempAcqFreq, 'None'))))
            acqFreqForPlotting = char(tempAcqFreq);
        end
    end

    numericAcqDistFeet = NaN; 
    if any(strcmp(firstDataRow.Properties.VariableNames, 'DistanceAtAcquisition'))
        tempAcqDistStr = firstDataRow.DistanceAtAcquisition; 
        
        overallUnitsStr = 'Standard'; 
        if any(strcmp(firstDataRow.Properties.VariableNames, 'Units'))
             tempOverallUnits = firstDataRow.Units;
             if ~(ismissing(tempOverallUnits) || (isstring(tempOverallUnits) && strlength(tempOverallUnits)==0) || (ischar(tempOverallUnits) && isempty(tempOverallUnits)))
                overallUnitsStr = char(tempOverallUnits);
             else
                warning('Overall units for DistanceAtAcquisition context is missing/empty. Assuming Standard (feet).');
             end
        else
            warning('Units column for DistanceAtAcquisition context not found. Assuming Standard (feet).');
        end
        isOverallMetric = strcmpi(overallUnitsStr, "Metric");

        if ~(ismissing(tempAcqDistStr) || (isstring(tempAcqDistStr) && (tempAcqDistStr == "" || strcmpi(tempAcqDistStr, "None"))) || (ischar(tempAcqDistStr) && (isempty(tempAcqDistStr) || strcmpi(tempAcqDistStr, 'None'))))
            tempNumericAcqDist = str2double(char(tempAcqDistStr));
            if ~isnan(tempNumericAcqDist)
                if isOverallMetric
                    numericAcqDistFeet = tempNumericAcqDist * METERS_TO_FEET;
                else
                    numericAcqDistFeet = tempNumericAcqDist; 
                end
            else
                 warning('DistanceAtAcquisition \'\'%s\'\' from file header is not a valid number.', char(tempAcqDistStr));
            end
        end
    end

    % Determine frequencies to plot
    originalWaveformData = waveformData; % Keep a copy of the full waveform data before filtering

    if isempty(specificFrequencies)
        disp('No specific frequencies provided by user.');
        if ~strcmpi(acqFreqForPlotting, 'N/A')
            disp(['Attempting to plot SelectedFrequencyAtAcquisition: ' acqFreqForPlotting]);
            % Check if this frequency exists and has data in the original waveform data
            freqExistsMask = strcmp(originalWaveformData.MeasurementFrequency, acqFreqForPlotting);
            if any(freqExistsMask)
                waveformData = originalWaveformData(freqExistsMask, :); % Use only data for this frequency
                frequenciesToPlot = {acqFreqForPlotting};
                disp(['Successfully selected data for: ' acqFreqForPlotting]);
            else
                disp(['Warning: SelectedFrequencyAtAcquisition (' acqFreqForPlotting ') not found or has no waveform data. Plotting all available frequencies instead.']);
                waveformData = originalWaveformData; % Use all original waveform data
                frequenciesToPlot = unique(waveformData.MeasurementFrequency, 'stable');
            end
        else
            disp('SelectedFrequencyAtAcquisition not available/invalid. Plotting all available waveform frequencies.');
            waveformData = originalWaveformData; % Use all original waveform data
            frequenciesToPlot = unique(waveformData.MeasurementFrequency, 'stable');
        end
    else % User provided specific frequencies
        userSpecifiedFreqs = string(specificFrequencies(:)'); % Ensure it's a string array
        validFreqMask = ismember(originalWaveformData.MeasurementFrequency, userSpecifiedFreqs);
        waveformData = originalWaveformData(validFreqMask, :);
        
        if isempty(waveformData)
            disp('None of the user-specified frequencies were found or have waveform data.');
            frequenciesToPlot = {}; % Set to empty to gracefully exit or be caught later
        else
            frequenciesToPlot = unique(waveformData.MeasurementFrequency, 'stable');
        end
        
        % Check and report if any user-specified frequencies were not found (even if some were)
        foundInPlotData = unique(waveformData.MeasurementFrequency); % Freqs that will actually be plotted
        notFoundFreqs = setdiff(userSpecifiedFreqs, foundInPlotData);
        if ~isempty(notFoundFreqs)
            disp('Warning: The following user-specified frequencies were not found or had no waveform data after filtering:');
            disp(strjoin(notFoundFreqs, ', '));
        end
    end

    if isempty(frequenciesToPlot)
        disp('No frequencies to plot after filtering.');
        return;
    end

    numPlots = length(frequenciesToPlot);
    
    % Constants
    METERS_TO_FEET = 3.28084;

    % Create a new figure
    fig = figure;
    try % Use try-catch for sgtitle in older MATLAB versions
        titleStr = sprintf('Waveforms for Serial: %s, Cable: %s', serialNumStr, cableNameStr);
        sgtitle(titleStr);
    catch
        % For older MATLAB versions that don't have sgtitle, use a workaround
        warning('sgtitle not available. Setting figure Name. May overlap.');
        set(gcf, 'Name', sprintf('S: %s, C: %s', serialNumStr, cableNameStr));
    end
    
    % Use tiled layout
    tlo = tiledlayout('flow', 'TileSpacing', 'compact', 'Padding', 'compact');

    for i = 1:numPlots
        currentFreq = frequenciesToPlot(i);
        freqDataRows = waveformData.MeasurementFrequency == currentFreq;
        freqData = waveformData(freqDataRows, :);
        
        if isempty(freqData)
            disp(['Skipping frequency ' char(currentFreq) ' as no data remains after filtering.']);
            continue;
        end

        % --- Y-axis Normalization (Scale by max absolute value) ---
        y_values = freqData.Value;
        max_abs_y = max(abs(y_values));

        if max_abs_y == 0
            normalized_y_original = zeros(size(y_values));
        else
            normalized_y_original = y_values / max_abs_y;
        end

        % --- X-axis Distance in Feet ---
        dataIndex = freqData.DataIndex;
        
        currentUnitsPerSampleStr = freqData.UnitsPerSample(1);
        if isstring(currentUnitsPerSampleStr) || ischar(currentUnitsPerSampleStr)
            currentUnitsPerSample = str2double(currentUnitsPerSampleStr);
        else
            currentUnitsPerSample = currentUnitsPerSampleStr; 
        end
        if isnan(currentUnitsPerSample) || isempty(currentUnitsPerSample) || currentUnitsPerSample <= 0
            warning('Invalid or missing UnitsPerSample for frequency %s. Using 1.0.', char(currentFreq));
            currentUnitsPerSample = 1.0;
        end
        distance_original_units = dataIndex .* currentUnitsPerSample;

        unitsStr = freqData.Units(1);
        if ismissing(unitsStr) || unitsStr == ""
            warning('Units (Standard/Metric) not found for frequency %s. Assuming Standard (feet).', char(currentFreq));
            unitsStr = "Standard";
        end
        isMetric = strcmpi(unitsStr, "Metric");
        
        distance_feet_original = distance_original_units;
        if isMetric 
            distance_feet_original = distance_original_units .* METERS_TO_FEET;
        end

        % --- Apply ZeroIndex Offset ---
        currentZeroIndexStr = freqData.ZeroIndex(1);
        if isstring(currentZeroIndexStr) || ischar(currentZeroIndexStr)
            currentZeroIndex = str2double(currentZeroIndexStr);
        else
            currentZeroIndex = currentZeroIndexStr; % Assume already numeric
        end
        if isnan(currentZeroIndex) || isempty(currentZeroIndex)
            warning('Invalid or missing ZeroIndex for frequency %s. Using 0.0.', char(currentFreq));
            currentZeroIndex = 0.0;
        end

        zero_offset_original_units = currentZeroIndex * currentUnitsPerSample;
        zero_offset_feet = zero_offset_original_units;
        if isMetric
            zero_offset_feet = zero_offset_original_units * METERS_TO_FEET;
        end
        
        distance_feet_shifted = distance_feet_original - zero_offset_feet;
        
        x_plot = distance_feet_shifted;
        y_plot = normalized_y_original; % Plotting raw normalized data

        nexttile(tlo);
        if ~isempty(x_plot) && ~isempty(y_plot)
            plot(x_plot, y_plot);
            hold on; % Prepare to add vertical lines

            % Add vertical line at x=0 (which is the ZeroIndex location for this plot)
            current_xlim = xlim;
            if 0 >= current_xlim(1) && 0 <= current_xlim(2)
                line([0 0], [-1.1, 1.1], 'Color', 'b', 'LineStyle', ':', 'LineWidth', 1, 'DisplayName', 'Zero Index');
            end

            % Add vertical line for DistanceAtAcquisition
            if ~isnan(numericAcqDistFeet)
                acqDistLinePositionOnPlot = numericAcqDistFeet; % Always use numericAcqDistFeet from header

                if acqDistLinePositionOnPlot >= current_xlim(1) && acqDistLinePositionOnPlot <= current_xlim(2)
                    line([acqDistLinePositionOnPlot acqDistLinePositionOnPlot], [-1.1, 1.1], 'Color', 'b', 'LineStyle', ':', 'LineWidth', 1, 'DisplayName', 'Acq. Distance');
                end
            end
            hold off;

        elseif ~isempty(distance_feet_shifted) && ~isempty(normalized_y_original) 
            % This case should ideally be handled by the primary plot logic now
            % If x_plot or y_plot were empty, it means normalized_y_original was empty.
            % If normalized_y_original was not empty, then x_plot and y_plot should not be empty.
            % However, to be safe, if we reach here it means primary plot failed somehow.
            plot(distance_feet_shifted, normalized_y_original); % Fallback, should be x_plot, y_plot
            disp(['Fallback: Plotting original normalized data (with ZeroIndex shift) for frequency ' char(currentFreq) '. Review logic if this message appears.']);
        else
            disp(['No data to plot for frequency ' char(currentFreq) '.']);
            % Optionally, you could plot an empty graph or skip the tile
            title(char(currentFreq));
            xlabel('Distance (ft)');
            ylabel('Normalized Value');
            text(0.5, 0.5, 'No Data', 'HorizontalAlignment', 'center');
            ylim([-1.1, 1.1]); 
            grid on;
            continue; % Skip to next frequency if no data at all
        end
        
        title(char(currentFreq));
        
        xlabel('Distance (ft)');
        ylabel('Normalized Value');
        ylim([-1.1, 1.1]); 
        grid on;
        axis tight; 
        ylim([-1.1, 1.1]);

    end

    if numPlots == 0 && ~isempty(specificFrequencies)
        disp('No data plotted. Ensure specified frequencies exist and have waveform data.')
    elseif numPlots == 0
        disp('No waveform data found to plot.')
    end

end
