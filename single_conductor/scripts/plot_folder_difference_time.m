function fig_handle = plot_folder_difference_time(folderPath, specificFrequency, confidence_level, l)
% plot_folder_difference_time Plot differences between grouped measurements at a given frequency.
%   fig_handle = plot_folder_difference_time(folderPath, specificFrequency, confidence_level, l)
% 
% folderPath: path to folder containing CSV files generated by convert_lws_csv.m
% specificFrequency: string specifying the measurement frequency to plot (e.g. '48 MHz')
% confidence_level: confidence level for error bars (default: 0.95 for 95% CI)
% l: feeder cable length in feet (optional, adds vertical line and updates title)
%
% Groups all T00_X files together, all T10_X files together, etc.
% Calculates group statistics and plots (T0X_group_avg - T1X_group_avg)/2 with confidence intervals.
% X-axis is converted to time using VOP and speed of light.
% Legend uses conductor distances from measurements.csv.

    % Input validation
    if nargin < 2
        error('Usage: plot_folder_difference_time(folderPath, specificFrequency, [confidence_level], [l])');
    end
    if nargin < 3
        confidence_level = 0.95; % Default 95% confidence interval
    end
    if nargin < 4
        l = []; % No feeder length specified
    end
    if ~isfolder(folderPath)
        error('Folder not found: %s', folderPath);
    end

    % Convert frequency input to string for comparison
    specificFrequency = string(specificFrequency);

    % Load measurements.csv to get conductor distances
    measurements_file = fullfile(fileparts(fileparts(folderPath)), 'measurements.csv');
    if ~isfile(measurements_file)
        measurements_file = fullfile(fileparts(fileparts(fileparts(folderPath))), 'measurements.csv');
    end
    
    measurements_map = containers.Map();
    if isfile(measurements_file)
        try
            measurements = readtable(measurements_file, 'Delimiter', ';', 'VariableNamingRule', 'preserve');
            % Convert to cell arrays for easier handling
            ids = table2cell(measurements(:, 1));
            heights = table2cell(measurements(:, 2));
            
            for i = 1:length(ids)
                id = ids{i};
                height_val = heights{i};
                % Convert height to string if it's numeric or other type
                if isnumeric(height_val)
                    height_str = num2str(height_val);
                elseif ischar(height_val) || isstring(height_val)
                    height_str = char(height_val);
                else
                    height_str = 'NA';
                end
                
                if ~strcmp(height_str, 'NA')
                    measurements_map(id) = height_str;
                end
            end
        catch ME
            warning('Could not load measurements.csv: %s', char(ME.message));
        end
    end

    % List CSV files
    files = dir(fullfile(folderPath, '*.csv'));
    if isempty(files)
        error('No CSV files found in folder: %s', folderPath);
    end

    % Parse filenames to extract group identifiers (e.g., T00, T05, T10, T15)
    fileData = struct('filename', {}, 'groupId', {}, 'replicateId', {});
    
    for i = 1:numel(files)
        fname = files(i).name;
        % Look for pattern T##_X.csv where ## are the group digits and X is the replicate
        tokens = regexp(fname, '^T(\d{2})_(.+)\.csv$', 'tokens');
        if ~isempty(tokens)
            groupNum = str2double(tokens{1}{1});
            replicateId = tokens{1}{2};
            fileData(end+1) = struct('filename', fname, 'groupId', groupNum, 'replicateId', replicateId);
        end
    end
    
    if isempty(fileData)
        error('No files matching pattern T##_X.csv found in folder: %s', folderPath);
    end

    % Group files by their group ID
    groupIds = unique([fileData.groupId]);
    groups = containers.Map('KeyType', 'int32', 'ValueType', 'any');
    
    for gid = groupIds
        groupFiles = {fileData([fileData.groupId] == gid).filename};
        groups(gid) = groupFiles;
        fprintf('Group T%02d: %d replicates\n', gid, length(groupFiles));
    end

    % Create pairs: T0X groups pair with T1X groups
    pairs = {};
    usedGroups = [];
    
    for gid = groupIds
        if ismember(gid, usedGroups)
            continue;
        end
        
        tens = floor(gid / 10);
        units = mod(gid, 10);
        
        % Look for partner: if tens digit is even, partner has tens+1; if odd, partner has tens-1
        if mod(tens, 2) == 0
            partnerTens = tens + 1;
        else
            partnerTens = tens - 1;
        end
        partnerGroupId = partnerTens * 10 + units;
        
        if ismember(partnerGroupId, groupIds)
            pairs{end+1} = [gid, partnerGroupId];
            usedGroups = [usedGroups, gid, partnerGroupId];
            fprintf('Paired group T%02d with T%02d\n', gid, partnerGroupId);
        else
            fprintf('Warning: No partner found for group T%02d\n', gid);
        end
    end
    
    if isempty(pairs)
        error('No valid group pairs found in the data');
    end

    % Prepare figure
    fig_handle = figure;
    hold on;
    xlabel('Time (ns)');
    ylabel('Normalized Difference / 2');
    
    % Create title with feeder length if specified
    if ~isempty(l)
        title(sprintf('Group Measurement Differences at %s (with %g%% CI) (l=%gft)', specificFrequency, confidence_level*100, l));
    else
        title(sprintf('Group Measurement Differences at %s (with %g%% CI)', specificFrequency, confidence_level*100));
    end

    % Sort pairs by the lower group number for consistent rainbow ordering
    numPairs = numel(pairs);
    pairData = cell(numPairs, 1);
    for i = 1:numPairs
        pair = pairs{i};
        lowerGroup = min(pair);
        pairData{i} = struct('pair', pair, 'lowerGroup', lowerGroup, 'originalIdx', i);
    end
    
    % Sort by lower group number
    [~, sortIdx] = sort(cellfun(@(x) x.lowerGroup, pairData));
    sortedPairData = pairData(sortIdx);
    
    % Assign rainbow colors (red to blue, avoiding pink) based on sorted order
    % Create custom colormap from red to blue (hue from 0 to 2/3)
    hue_values = linspace(0, 2/3, numPairs); % 0 = red, 1/3 = green, 2/3 = blue
    hsvColors = zeros(numPairs, 3);
    for i = 1:numPairs
        hsvColors(i, :) = hsv2rgb([hue_values(i), 1, 1]); % Full saturation and value
    end
    
    for pairIdx = 1:numPairs
        % Get the sorted pair data
        currentPairData = sortedPairData{pairIdx};
        pair = currentPairData.pair;
        group1Id = pair(1);
        group2Id = pair(2);
        
        group1Files = groups(group1Id);
        group2Files = groups(group2Id);
        
        % Load and process all files in group 1
        [x_common, group1_stats] = processGroupFilesTime(folderPath, group1Files, specificFrequency);
        if isempty(x_common)
            fprintf('Warning: No valid data found in group T%02d\n', group1Id);
            continue;
        end
        
        % Load and process all files in group 2
        [x_common2, group2_stats] = processGroupFilesTime(folderPath, group2Files, specificFrequency);
        if isempty(x_common2)
            fprintf('Warning: No valid data found in group T%02d\n', group2Id);
            continue;
        end
        
        % Ensure both groups have the same x-axis
        x_min = max(min(x_common), min(x_common2));
        x_max = min(max(x_common), max(x_common2));
        dx = min(mean(diff(x_common)), mean(diff(x_common2)));
        x_final = x_min:dx:x_max;
        
        if length(x_final) < 2
            fprintf('Warning: Insufficient overlap between groups T%02d and T%02d\n', group1Id, group2Id);
            continue;
        end
        
        % Interpolate group statistics to common x-axis
        group1_mean_interp = interp1(x_common, group1_stats.mean, x_final, 'linear', 'extrap');
        group1_std_interp = interp1(x_common, group1_stats.std, x_final, 'linear', 'extrap');
        group1_n_interp = interp1(x_common, group1_stats.n, x_final, 'nearest', 'extrap');
        
        group2_mean_interp = interp1(x_common2, group2_stats.mean, x_final, 'linear', 'extrap');
        group2_std_interp = interp1(x_common2, group2_stats.std, x_final, 'linear', 'extrap');
        group2_n_interp = interp1(x_common2, group2_stats.n, x_final, 'nearest', 'extrap');
        
        % Calculate difference of means divided by 2
        diff_means = (group1_mean_interp - group2_mean_interp) / 2;
        
        % Calculate standard error of the difference divided by 2
        % SE(diff/2) = sqrt(SE1^2 + SE2^2) / 2
        se1 = group1_std_interp ./ sqrt(group1_n_interp);
        se2 = group2_std_interp ./ sqrt(group2_n_interp);
        se_diff = sqrt(se1.^2 + se2.^2) / 2;
        
        % Calculate confidence interval bounds using pooled degrees of freedom
        df1 = group1_n_interp - 1;
        df2 = group2_n_interp - 1;
        pooled_df = df1 + df2;
        
        alpha = 1 - confidence_level;
        t_vals = arrayfun(@(df) tinv(1 - alpha/2, max(df, 1)), pooled_df);
        ci_bounds = t_vals .* se_diff;
        
        % Plot the difference with error bands
        color = hsvColors(pairIdx, :);
        
        % Plot confidence interval as shaded area
        x_fill = [x_final, fliplr(x_final)];
        y_fill = [diff_means + ci_bounds, fliplr(diff_means - ci_bounds)];
        fill(x_fill, y_fill, color, 'FaceAlpha', 0.2, 'EdgeColor', 'none', 'HandleVisibility', 'off');
        
        % Create label using conductor distances if available
        group1_key = sprintf('T%02d', group1Id);
        group2_key = sprintf('T%02d', group2Id);
        
        if isKey(measurements_map, group1_key) && isKey(measurements_map, group2_key)
            height1 = measurements_map(group1_key);
            height2 = measurements_map(group2_key);
            pairLabel = sprintf('d: %s in (n=%d,%d)', height1, ...
                               round(mean(group1_n_interp)), round(mean(group2_n_interp)));
        else
            pairLabel = sprintf('T%02d-T%02d (n=%d,%d)', group1Id, group2Id, ...
                               round(mean(group1_n_interp)), round(mean(group2_n_interp)));
        end
        
        % Plot main line
        plot(x_final, diff_means, 'Color', color, 'LineWidth', 1.5, 'DisplayName', pairLabel);
    end
    
    % Add feeder line length as vertical dashed line if specified
    if ~isempty(l)
        % Convert feeder length to time using VOP = 0.66
        vop = 0.66;
        speed_of_light_ft_per_s = 983571056; % ft/s
        speed_in_cable = speed_of_light_ft_per_s * vop; % ft/s
        % Round trip time: multiply by 2 (signal goes down and back up)
        feeder_time_ns = (l * 2) / speed_in_cable * 1e9; % Convert to nanoseconds
        
        % Get current y-axis limits to draw line across full height
        ylims = ylim;
        
        % Plot vertical dashed line
        line([feeder_time_ns, feeder_time_ns], ylims, 'Color', 'k', 'LineStyle', '--', ...
             'LineWidth', 1.5, 'DisplayName', 'Feeder Line Length');
    end

    % Add legend and grid
    legend('show', 'Location', 'best');
    grid on;
    hold off;
end

function [x_common, group_stats] = processGroupFilesTime(folderPath, filenames, specificFrequency)
    % Process all files in a group and calculate statistics
    x_common = [];
    group_stats = struct('mean', [], 'std', [], 'n', []);
    
    % Load all files and collect their data
    all_x = {};
    all_y = {};
    valid_files = 0;
    
    for i = 1:length(filenames)
        [x_vals, y_vals] = loadAndProcessFileTime(fullfile(folderPath, filenames{i}), specificFrequency);
        if ~isempty(x_vals)
            all_x{end+1} = x_vals;
            all_y{end+1} = y_vals;
            valid_files = valid_files + 1;
        end
    end
    
    if valid_files == 0
        return;
    end
    
    % Find common x-axis range across all files
    x_min = max(cellfun(@min, all_x));
    x_max = min(cellfun(@max, all_x));
    
    % Use the finest resolution among all files
    dx_vals = cellfun(@(x) mean(diff(x)), all_x);
    dx = min(dx_vals);
    
    x_common = x_min:dx:x_max;
    
    if length(x_common) < 2
        return;
    end
    
    % Interpolate all signals to common x-axis
    y_matrix = zeros(length(x_common), valid_files);
    
    for i = 1:valid_files
        y_interp = interp1(all_x{i}, all_y{i}, x_common, 'linear', 'extrap');
        y_matrix(:, i) = y_interp;
    end
    
    % Calculate statistics across replicates at each x position
    group_stats.mean = mean(y_matrix, 2)';
    group_stats.std = std(y_matrix, 0, 2)'; % Sample standard deviation
    group_stats.n = repmat(valid_files, size(group_stats.mean)); % Number of replicates
    
    % Handle case where std is 0 (all replicates identical)
    min_std = 0.001 * (max(group_stats.mean) - min(group_stats.mean));
    group_stats.std = max(group_stats.std, min_std);
end

function [x_vals, y_vals] = loadAndProcessFileTime(fullFilePath, specificFrequency)
    % Load and process a single CSV file, converting distance to time
    x_vals = [];
    y_vals = [];
    
    try
        opts = detectImportOptions(fullFilePath);
        % Ensure certain columns are read as strings
        forceStringCols = {'UnitsPerSample', 'ZeroIndex', 'Units', 'MeasurementFrequency', 'DataType', 'VOP'};
        for k = 1:numel(forceStringCols)
            col = forceStringCols{k};
            if any(strcmp(opts.VariableNames, col))
                opts = setvartype(opts, col, 'string');
            end
        end
        tbl = readtable(fullFilePath, opts);
    catch ME
        warning('Failed to read %s: %s', fullFilePath, char(ME.message));
        return;
    end

    % Filter for waveform data at the specified frequency
    isWave = strcmpi(tbl.DataType, 'Waveform');
    isFreq = tbl.MeasurementFrequency == specificFrequency;
    data = tbl(isWave & isFreq, :);
    if isempty(data)
        return;
    end

    % Compute normalized Y values
    y_raw = data.Value;
    max_abs_y = max(abs(y_raw));
    if max_abs_y == 0
        y_vals = zeros(size(y_raw));
    else
        y_vals = y_raw / max_abs_y;
    end

    % Get VOP value from the data
    vop_str = data.VOP(1);
    vop = str2double(vop_str);
    if isnan(vop) || vop <= 0
        vop = 0.66; % Default VOP value
    end

    % Compute X values (distance in feet, shifted by zero index)
    idx = data.DataIndex;
    % UnitsPerSample conversion
    ups_str = data.UnitsPerSample(1);
    ups = str2double(ups_str);
    if isnan(ups) || ups <= 0
        ups = 1.0;
    end
    raw_dist = idx * ups;
    % Metric vs Standard units
    unitStr = data.Units(1);
    isMetric = strcmpi(unitStr, 'Metric');
    METERS_TO_FEET = 3.28084;
    dist_ft = raw_dist * (isMetric * METERS_TO_FEET + ~isMetric);

    % ZeroIndex offset
    zi_str = data.ZeroIndex(1);
    zi = str2double(zi_str);
    if isnan(zi)
        zi = 0;
    end
    zero_offset = zi * ups * (isMetric * METERS_TO_FEET + ~isMetric);
    dist_ft_corrected = dist_ft - zero_offset;
    
    % Convert distance to time using VOP and speed of light
    % time = distance / (speed_of_light * VOP)
    % Speed of light = 299,792,458 m/s = 983,571,056 ft/s
    speed_of_light_ft_per_s = 983571056; % ft/s
    speed_in_cable = speed_of_light_ft_per_s * vop; % ft/s
    
    % Convert to time in nanoseconds
    % Round trip time: multiply by 2 (signal goes down and back up)
    x_vals = (dist_ft_corrected * 2) / speed_in_cable * 1e9; % Convert to nanoseconds
end 