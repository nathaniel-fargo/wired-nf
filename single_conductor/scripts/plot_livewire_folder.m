function fig_handle = plot_livewire_folder(folderPath, specificFrequency, confidence_level)
% plot_livewire_folder Plot group means with confidence intervals for CSV files in a folder.
%   fig_handle = plot_livewire_folder(folderPath, specificFrequency, confidence_level)
% 
% folderPath: path to folder containing CSV files generated by convert_lws_csv.m
% specificFrequency: string specifying the measurement frequency to plot (e.g. '48 MHz')
% confidence_level: confidence level for error bars (default: 0.95 for 95% CI)
%
% Each measurement group (determined by first 3 characters of filename) will get its own color.
% Shows group means with confidence interval bands instead of individual waveforms.

    % Input validation
    if nargin < 2
        error('Usage: plot_livewire_folder(folderPath, specificFrequency, [confidence_level])');
    end
    if nargin < 3
        confidence_level = 0.95; % Default 95% confidence interval
    end
    if ~isfolder(folderPath)
        error('Folder not found: %s', folderPath);
    end

    % Convert frequency input to string for comparison
    specificFrequency = string(specificFrequency);

    % List CSV files
    files = dir(fullfile(folderPath, '*.csv'));
    if isempty(files)
        error('No CSV files found in folder: %s', folderPath);
    end

    % Extract group names from filenames (first 3 characters)
    groupNames = cell(1, numel(files));
    for i = 1:numel(files)
        fname = files(i).name;
        if numel(fname) >= 3
            groupNames{i} = fname(1:3);
        else
            groupNames{i} = fname;
        end
    end
    
    % Group files by their group names
    uniqueGroups = unique(groupNames); % alphabetical order
    numGroups = numel(uniqueGroups);
    groups = containers.Map('KeyType', 'char', 'ValueType', 'any');
    
    for i = 1:numGroups
        grpName = uniqueGroups{i};
        groupFiles = {files(strcmp(groupNames, grpName)).name};
        groups(grpName) = groupFiles;
        fprintf('Group %s: %d replicates\n', grpName, length(groupFiles));
    end

    % Assign rainbow colors via HSV colormap
    colorMap = hsv(numGroups); % HSV colormap for rainbow colors
    groupColorMap = containers.Map(uniqueGroups, num2cell(colorMap, 2));

    % Prepare figure
    fig_handle = figure;
    hold on;
    xlabel('Distance (ft)');
    ylabel('Normalized Value');
    title(sprintf('Group Means with %g%% CI at %s', confidence_level*100, specificFrequency));

    METERS_TO_FEET = 3.28084;

    % Process each group and plot with confidence intervals
    for i = 1:numGroups
        grpName = uniqueGroups{i};
        groupFiles = groups(grpName);
        
        % Load and process all files in this group
        [x_common, group_stats] = processGroupFiles(folderPath, groupFiles, specificFrequency, METERS_TO_FEET);
        if isempty(x_common)
            fprintf('Warning: No valid data found in group %s\n', grpName);
            continue;
        end
        
        % Calculate confidence intervals
        se = group_stats.std ./ sqrt(group_stats.n);
        df = group_stats.n - 1;
        alpha = 1 - confidence_level;
        t_vals = arrayfun(@(df_val) tinv(1 - alpha/2, max(df_val, 1)), df);
        ci_bounds = t_vals .* se;
        
        % Plot confidence interval as shaded area
        color = groupColorMap(grpName);
        x_fill = [x_common, fliplr(x_common)];
        y_fill = [group_stats.mean + ci_bounds, fliplr(group_stats.mean - ci_bounds)];
        fill(x_fill, y_fill, color, 'FaceAlpha', 0.2, 'EdgeColor', 'none', 'HandleVisibility', 'off');
        
        % Plot main line
        groupLabel = sprintf('%s (n=%d)', grpName, round(mean(group_stats.n)));
        plot(x_common, group_stats.mean, 'Color', color, 'LineWidth', 1.5, 'DisplayName', groupLabel);
    end

    % Add legend and grid
    legend('show', 'Location', 'best');
    grid on;
    hold off;
end

function [x_common, group_stats] = processGroupFiles(folderPath, filenames, specificFrequency, METERS_TO_FEET)
    % Process all files in a group and calculate statistics
    x_common = [];
    group_stats = struct('mean', [], 'std', [], 'n', []);
    
    % Load all files and collect their data
    all_x = {};
    all_y = {};
    valid_files = 0;
    
    for i = 1:length(filenames)
        [x_vals, y_vals] = loadAndProcessFile(fullfile(folderPath, filenames{i}), specificFrequency, METERS_TO_FEET);
        if ~isempty(x_vals)
            all_x{end+1} = x_vals;
            all_y{end+1} = y_vals;
            valid_files = valid_files + 1;
        end
    end
    
    if valid_files == 0
        return;
    end
    
    % Find common x-axis range across all files
    x_min = max(cellfun(@min, all_x));
    x_max = min(cellfun(@max, all_x));
    
    % Use the finest resolution among all files
    dx_vals = cellfun(@(x) mean(diff(x)), all_x);
    dx = min(dx_vals);
    
    x_common = x_min:dx:x_max;
    
    if length(x_common) < 2
        return;
    end
    
    % Interpolate all signals to common x-axis
    y_matrix = zeros(length(x_common), valid_files);
    
    for i = 1:valid_files
        y_interp = interp1(all_x{i}, all_y{i}, x_common, 'linear', 'extrap');
        y_matrix(:, i) = y_interp;
    end
    
    % Calculate statistics across replicates at each x position
    group_stats.mean = mean(y_matrix, 2)';
    group_stats.std = std(y_matrix, 0, 2)'; % Sample standard deviation
    group_stats.n = repmat(valid_files, size(group_stats.mean)); % Number of replicates
    
    % Handle case where std is 0 (all replicates identical)
    min_std = 0.001 * (max(group_stats.mean) - min(group_stats.mean));
    group_stats.std = max(group_stats.std, min_std);
end

function [x_vals, y_vals] = loadAndProcessFile(fullFilePath, specificFrequency, METERS_TO_FEET)
    % Load and process a single CSV file
    x_vals = [];
    y_vals = [];
    
    try
        opts = detectImportOptions(fullFilePath);
        % Ensure certain columns are read as strings
        forceStringCols = {'UnitsPerSample', 'ZeroIndex', 'Units', 'MeasurementFrequency', 'DataType'};
        for k = 1:numel(forceStringCols)
            col = forceStringCols{k};
            if any(strcmp(opts.VariableNames, col))
                opts = setvartype(opts, col, 'string');
            end
        end
        tbl = readtable(fullFilePath, opts);
    catch ME
        warning('Failed to read %s: %s', fullFilePath, ME.message);
        return;
    end

    % Filter for waveform data at the specified frequency
    isWave = strcmpi(tbl.DataType, 'Waveform');
    isFreq = tbl.MeasurementFrequency == specificFrequency;
    data = tbl(isWave & isFreq, :);
    if isempty(data)
        return;
    end

    % Compute normalized Y values
    y_raw = data.Value;
    max_abs_y = max(abs(y_raw));
    if max_abs_y == 0
        y_vals = zeros(size(y_raw));
    else
        y_vals = y_raw / max_abs_y;
    end

    % Compute X values (distance in feet, shifted by zero index)
    idx = data.DataIndex;
    % UnitsPerSample conversion
    ups_str = data.UnitsPerSample(1);
    ups = str2double(ups_str);
    if isnan(ups) || ups <= 0
        ups = 1.0;
    end
    raw_dist = idx * ups;
    % Metric vs Standard units
    unitStr = data.Units(1);
    isMetric = strcmpi(unitStr, 'Metric');
    dist_ft = raw_dist * (isMetric * METERS_TO_FEET + ~isMetric);

    % ZeroIndex offset
    zi_str = data.ZeroIndex(1);
    zi = str2double(zi_str);
    if isnan(zi)
        zi = 0;
    end
    zero_offset = zi * ups * (isMetric * METERS_TO_FEET + ~isMetric);
    x_vals = dist_ft - zero_offset;
end 