% plot_folder_difference.m
%
% Plots the difference between two groups of measurements at a given frequency.
%
% Author: Nathaniel Fargo
% Date: 2025-06-09
% Org: U of U WIRED
%
% Developed partially with AI assistance.
%
% Usage:
%   plot_folder_difference('path/to/folder', '48 MHz');
%   plot_folder_difference('path/to/folder', '48 MHz', 0.95);

function fig_handle = plot_folder_difference(folderPath, specificFrequency, confidence_level)
% plot_folder_difference Plot differences between grouped measurements at a given frequency.
%   fig_handle = plot_folder_difference(folderPath, specificFrequency, confidence_level)
% 
% folderPath: path to folder containing CSV files generated by convert_lws_csv.m
% specificFrequency: string specifying the measurement frequency to plot (e.g. '48 MHz')
% confidence_level: confidence level for error bars (default: 0.95 for 95% CI)
%
% Groups all T00_X files together, all T10_X files together, etc.
% Calculates group statistics and plots (T0X_group_avg - T1X_group_avg)/2 with confidence intervals.

    % Input validation
    if nargin < 2
        error('Usage: plot_folder_difference(folderPath, specificFrequency, [confidence_level])');
    end
    if nargin < 3
        confidence_level = 0.95; % Default 95% confidence interval
    end
    if ~isfolder(folderPath)
        error('Folder not found: %s', folderPath);
    end

    % Convert frequency input to string for comparison
    specificFrequency = string(specificFrequency);

    % List CSV files
    files = dir(fullfile(folderPath, '*.csv'));
    if isempty(files)
        error('No CSV files found in folder: %s', folderPath);
    end

    % Parse filenames to extract group identifiers (e.g., T00, T05, T10, T15)
    fileData = struct('filename', {}, 'groupId', {}, 'replicateId', {});
    
    for i = 1:numel(files)
        fname = files(i).name;
        % Look for pattern T##_X.csv where ## are the group digits and X is the replicate
        tokens = regexp(fname, '^T(\d{2})_(.+)\.csv$', 'tokens');
        if ~isempty(tokens)
            groupNum = str2double(tokens{1}{1});
            replicateId = tokens{1}{2};
            fileData(end+1) = struct('filename', fname, 'groupId', groupNum, 'replicateId', replicateId);
        end
    end
    
    if isempty(fileData)
        error('No files matching pattern T##_X.csv found in folder: %s', folderPath);
    end

    % Group files by their group ID
    groupIds = unique([fileData.groupId]);
    groups = containers.Map('KeyType', 'int32', 'ValueType', 'any');
    
    for gid = groupIds
        groupFiles = {fileData([fileData.groupId] == gid).filename};
        groups(gid) = groupFiles;
        fprintf('Group T%02d: %d replicates\n', gid, length(groupFiles));
    end

    % Create pairs: T0X groups pair with T1X groups
    pairs = {};
    usedGroups = [];
    
    for gid = groupIds
        if ismember(gid, usedGroups)
            continue;
        end
        
        tens = floor(gid / 10);
        units = mod(gid, 10);
        
        % Look for partner: if tens digit is even, partner has tens+1; if odd, partner has tens-1
        if mod(tens, 2) == 0
            partnerTens = tens + 1;
        else
            partnerTens = tens - 1;
        end
        partnerGroupId = partnerTens * 10 + units;
        
        if ismember(partnerGroupId, groupIds)
            pairs{end+1} = [gid, partnerGroupId];
            usedGroups = [usedGroups, gid, partnerGroupId];
            fprintf('Paired group T%02d with T%02d\n', gid, partnerGroupId);
        else
            fprintf('Warning: No partner found for group T%02d\n', gid);
        end
    end
    
    if isempty(pairs)
        error('No valid group pairs found in the data');
    end

    % Process each group pair and calculate differences
    METERS_TO_FEET = 3.28084;
    
    % Prepare figure
    fig_handle = figure;
    hold on;
    xlabel('Distance (ft)');
    ylabel('Normalized Difference / 2');
    title(sprintf('Group Measurement Differences at %s (with %g%% CI)', specificFrequency, confidence_level*100));

    % Sort pairs by the lower group number for consistent rainbow ordering
    numPairs = numel(pairs);
    pairData = cell(numPairs, 1);
    for i = 1:numPairs
        pair = pairs{i};
        lowerGroup = min(pair);
        pairData{i} = struct('pair', pair, 'lowerGroup', lowerGroup, 'originalIdx', i);
    end
    
    % Sort by lower group number
    [~, sortIdx] = sort(cellfun(@(x) x.lowerGroup, pairData));
    sortedPairData = pairData(sortIdx);
    
    % Assign rainbow colors (red to blue, avoiding pink) based on sorted order
    % Create custom colormap from red to blue (hue from 0 to 2/3)
    hue_values = linspace(0, 2/3, numPairs); % 0 = red, 1/3 = green, 2/3 = blue
    hsvColors = zeros(numPairs, 3);
    for i = 1:numPairs
        hsvColors(i, :) = hsv2rgb([hue_values(i), 1, 1]); % Full saturation and value
    end
    
    for pairIdx = 1:numPairs
        % Get the sorted pair data
        currentPairData = sortedPairData{pairIdx};
        pair = currentPairData.pair;
        group1Id = pair(1);
        group2Id = pair(2);
        
        group1Files = groups(group1Id);
        group2Files = groups(group2Id);
        
        % Load and process all files in group 1
        [x_common, group1_stats] = processGroupFiles(folderPath, group1Files, specificFrequency, METERS_TO_FEET);
        if isempty(x_common)
            fprintf('Warning: No valid data found in group T%02d\n', group1Id);
            continue;
        end
        
        % Load and process all files in group 2
        [x_common2, group2_stats] = processGroupFiles(folderPath, group2Files, specificFrequency, METERS_TO_FEET);
        if isempty(x_common2)
            fprintf('Warning: No valid data found in group T%02d\n', group2Id);
            continue;
        end
        
        % Ensure both groups have the same x-axis
        x_min = max(min(x_common), min(x_common2));
        x_max = min(max(x_common), max(x_common2));
        dx = min(mean(diff(x_common)), mean(diff(x_common2)));
        x_final = x_min:dx:x_max;
        
        if length(x_final) < 2
            fprintf('Warning: Insufficient overlap between groups T%02d and T%02d\n', group1Id, group2Id);
            continue;
        end
        
        % Interpolate group statistics to common x-axis
        group1_mean_interp = interp1(x_common, group1_stats.mean, x_final, 'linear', 'extrap');
        group1_std_interp = interp1(x_common, group1_stats.std, x_final, 'linear', 'extrap');
        group1_n_interp = interp1(x_common, group1_stats.n, x_final, 'nearest', 'extrap');
        
        group2_mean_interp = interp1(x_common2, group2_stats.mean, x_final, 'linear', 'extrap');
        group2_std_interp = interp1(x_common2, group2_stats.std, x_final, 'linear', 'extrap');
        group2_n_interp = interp1(x_common2, group2_stats.n, x_final, 'nearest', 'extrap');
        
        % Calculate difference of means divided by 2
        diff_means = (group1_mean_interp - group2_mean_interp) / 2;
        
        % Calculate standard error of the difference divided by 2
        % SE(diff/2) = sqrt(SE1^2 + SE2^2) / 2
        se1 = group1_std_interp ./ sqrt(group1_n_interp);
        se2 = group2_std_interp ./ sqrt(group2_n_interp);
        se_diff = sqrt(se1.^2 + se2.^2) / 2;
        
        % Calculate confidence interval bounds using pooled degrees of freedom
        df1 = group1_n_interp - 1;
        df2 = group2_n_interp - 1;
        pooled_df = df1 + df2;
        
        alpha = 1 - confidence_level;
        t_vals = arrayfun(@(df) tinv(1 - alpha/2, max(df, 1)), pooled_df);
        ci_bounds = t_vals .* se_diff;
        
                 % Plot the difference with error bands
         color = hsvColors(pairIdx, :);
        
        % Plot confidence interval as shaded area
        x_fill = [x_final, fliplr(x_final)];
        y_fill = [diff_means + ci_bounds, fliplr(diff_means - ci_bounds)];
        fill(x_fill, y_fill, color, 'FaceAlpha', 0.2, 'EdgeColor', 'none', 'HandleVisibility', 'off');
        
        % Plot main line
        pairLabel = sprintf('T%02d-T%02d (n=%d,%d)', group1Id, group2Id, ...
                           round(mean(group1_n_interp)), round(mean(group2_n_interp)));
        plot(x_final, diff_means, 'Color', color, 'LineWidth', 1.5, 'DisplayName', pairLabel);
    end

    % Add legend and grid
    legend('show', 'Location', 'best');
    grid on;
    hold off;
end

function [x_common, group_stats] = processGroupFiles(folderPath, filenames, specificFrequency, METERS_TO_FEET)
    % Process all files in a group and calculate statistics
    x_common = [];
    group_stats = struct('mean', [], 'std', [], 'n', []);
    
    % Load all files and collect their data
    all_x = {};
    all_y = {};
    valid_files = 0;
    
    for i = 1:length(filenames)
        [x_vals, y_vals] = loadAndProcessFile(fullfile(folderPath, filenames{i}), specificFrequency, METERS_TO_FEET);
        if ~isempty(x_vals)
            all_x{end+1} = x_vals;
            all_y{end+1} = y_vals;
            valid_files = valid_files + 1;
        end
    end
    
    if valid_files == 0
        return;
    end
    
    % Find common x-axis range across all files
    x_min = max(cellfun(@min, all_x));
    x_max = min(cellfun(@max, all_x));
    
    % Use the finest resolution among all files
    dx_vals = cellfun(@(x) mean(diff(x)), all_x);
    dx = min(dx_vals);
    
    x_common = x_min:dx:x_max;
    
    if length(x_common) < 2
        return;
    end
    
    % Interpolate all signals to common x-axis
    y_matrix = zeros(length(x_common), valid_files);
    
    for i = 1:valid_files
        y_interp = interp1(all_x{i}, all_y{i}, x_common, 'linear', 'extrap');
        y_matrix(:, i) = y_interp;
    end
    
    % Calculate statistics across replicates at each x position
    group_stats.mean = mean(y_matrix, 2)';
    group_stats.std = std(y_matrix, 0, 2)'; % Sample standard deviation
    group_stats.n = repmat(valid_files, size(group_stats.mean)); % Number of replicates
    
    % Handle case where std is 0 (all replicates identical)
    min_std = 0.001 * (max(group_stats.mean) - min(group_stats.mean));
    group_stats.std = max(group_stats.std, min_std);
end

function [x_vals, y_vals] = loadAndProcessFile(fullFilePath, specificFrequency, METERS_TO_FEET)
    % Load and process a single CSV file
    x_vals = [];
    y_vals = [];
    
    try
        opts = detectImportOptions(fullFilePath);
        % Ensure certain columns are read as strings
        forceStringCols = {'UnitsPerSample', 'ZeroIndex', 'Units', 'MeasurementFrequency', 'DataType'};
        for k = 1:numel(forceStringCols)
            col = forceStringCols{k};
            if any(strcmp(opts.VariableNames, col))
                opts = setvartype(opts, col, 'string');
            end
        end
        tbl = readtable(fullFilePath, opts);
    catch ME
        warning('Failed to read %s: %s', fullFilePath, ME.message);
        return;
    end

    % Filter for waveform data at the specified frequency
    isWave = strcmpi(tbl.DataType, 'Waveform');
    isFreq = tbl.MeasurementFrequency == specificFrequency;
    data = tbl(isWave & isFreq, :);
    if isempty(data)
        return;
    end

    % Compute normalized Y values
    y_raw = data.Value;
    max_abs_y = max(abs(y_raw));
    if max_abs_y == 0
        y_vals = zeros(size(y_raw));
    else
        y_vals = y_raw / max_abs_y;
    end

    % Compute X values (distance in feet, shifted by zero index)
    idx = data.DataIndex;
    % UnitsPerSample conversion
    ups_str = data.UnitsPerSample(1);
    ups = str2double(ups_str);
    if isnan(ups) || ups <= 0
        ups = 1.0;
    end
    raw_dist = idx * ups;
    % Metric vs Standard units
    unitStr = data.Units(1);
    isMetric = strcmpi(unitStr, 'Metric');
    dist_ft = raw_dist * (isMetric * METERS_TO_FEET + ~isMetric);

    % ZeroIndex offset
    zi_str = data.ZeroIndex(1);
    zi = str2double(zi_str);
    if isnan(zi)
        zi = 0;
    end
    zero_offset = zi * ups * (isMetric * METERS_TO_FEET + ~isMetric);
    x_vals = dist_ft - zero_offset;
end
