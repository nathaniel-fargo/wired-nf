function fig_handle = plot_livewire_folder_time(folderPath, specificFrequency, confidence_level, l)
% plot_livewire_folder_time Plot group means with confidence intervals for CSV files in a folder.
%   fig_handle = plot_livewire_folder_time(folderPath, specificFrequency, confidence_level, l)
% 
% folderPath: path to folder containing CSV files generated by convert_lws_csv.m
% specificFrequency: string specifying the measurement frequency to plot (e.g. '48 MHz')
% confidence_level: confidence level for error bars (default: 0.95 for 95% CI)
% l: feeder cable length in feet (optional, adds vertical line and updates title)
%
% Each measurement group (determined by first 3 characters of filename) will get its own color.
% Shows group means with confidence interval bands instead of individual waveforms.
% X-axis is converted to time using VOP and speed of light.
% Legend uses conductor distances from measurements.csv.

    % Input validation
    if nargin < 2
        error('Usage: plot_livewire_folder_time(folderPath, specificFrequency, [confidence_level], [l])');
    end
    if nargin < 3
        confidence_level = 0.95; % Default 95% confidence interval
    end
    if nargin < 4
        l = []; % No feeder length specified
    end
    if ~isfolder(folderPath)
        error('Folder not found: %s', folderPath);
    end

    % Convert frequency input to string for comparison
    specificFrequency = string(specificFrequency);

    % Load measurements.csv to get conductor distances
    measurements_file = fullfile(fileparts(fileparts(folderPath)), 'measurements.csv');
    if ~isfile(measurements_file)
        measurements_file = fullfile(fileparts(fileparts(fileparts(folderPath))), 'measurements.csv');
    end
    
    measurements_map = containers.Map();
    if isfile(measurements_file)
        try
            measurements = readtable(measurements_file, 'Delimiter', ';', 'VariableNamingRule', 'preserve');
            % Convert to cell arrays for easier handling
            ids = table2cell(measurements(:, 1));
            heights = table2cell(measurements(:, 2));
            
            for i = 1:length(ids)
                id = ids{i};
                height_val = heights{i};
                % Convert height to string if it's numeric or other type
                if isnumeric(height_val)
                    height_str = num2str(height_val);
                elseif ischar(height_val) || isstring(height_val)
                    height_str = char(height_val);
                else
                    height_str = 'NA';
                end
                
                if ~strcmp(height_str, 'NA')
                    measurements_map(id) = height_str;
                end
            end
        catch ME
            warning('Could not load measurements.csv: %s', char(ME.message));
        end
    end

    % List CSV files
    files = dir(fullfile(folderPath, '*.csv'));
    if isempty(files)
        error('No CSV files found in folder: %s', folderPath);
    end

    % Extract group names from filenames (first 3 characters)
    groupNames = cell(1, numel(files));
    for i = 1:numel(files)
        fname = files(i).name;
        if numel(fname) >= 3
            groupNames{i} = fname(1:3);
        else
            groupNames{i} = fname;
        end
    end
    
    % Group files by their group names
    uniqueGroups = unique(groupNames); % alphabetical order
    numGroups = numel(uniqueGroups);
    groups = containers.Map('KeyType', 'char', 'ValueType', 'any');
    
    for i = 1:numGroups
        grpName = uniqueGroups{i};
        groupFiles = {files(strcmp(groupNames, grpName)).name};
        groups(grpName) = groupFiles;
        fprintf('Group %s: %d replicates\n', grpName, length(groupFiles));
    end

    % Separate control groups (Z00) from measurement groups
    controlGroups = {};
    measurementGroups = {};
    for i = 1:numGroups
        if strcmp(uniqueGroups{i}, 'Z00')
            controlGroups{end+1} = uniqueGroups{i};
        else
            measurementGroups{end+1} = uniqueGroups{i};
        end
    end
    
    % Assign colors: neutral for control, rainbow for measurements
    groupColorMap = containers.Map();
    
    % Assign neutral color for control groups
    for i = 1:length(controlGroups)
        groupColorMap(controlGroups{i}) = [0.5, 0.5, 0.5]; % Gray
    end
    
    % Assign rainbow colors for measurement groups
    if ~isempty(measurementGroups)
        colorMap = hsv(length(measurementGroups) + 1);
        for i = 1:length(measurementGroups)
            groupColorMap(measurementGroups{i}) = colorMap(i, :);
        end
    end

    % Prepare figure
    fig_handle = figure;
    hold on;
    xlabel('Time (ns)');
    ylabel('Normalized Value');
    
    % Create title with feeder length if specified
    if ~isempty(l)
        title(sprintf('Group Means with %g%% CI at %s (l=%gft)', confidence_level*100, specificFrequency, l));
    else
        title(sprintf('Group Means with %g%% CI at %s', confidence_level*100, specificFrequency));
    end

    % Process each group and plot with confidence intervals
    for i = 1:numGroups
        grpName = uniqueGroups{i};
        groupFiles = groups(grpName);
        
        % Load and process all files in this group
        [x_common, group_stats] = processGroupFilesTime(folderPath, groupFiles, specificFrequency);
        if isempty(x_common)
            fprintf('Warning: No valid data found in group %s\n', grpName);
            continue;
        end
        
        % Calculate confidence intervals
        se = group_stats.std ./ sqrt(group_stats.n);
        df = group_stats.n - 1;
        alpha = 1 - confidence_level;
        t_vals = arrayfun(@(df_val) tinv(1 - alpha/2, max(df_val, 1)), df);
        ci_bounds = t_vals .* se;
        
        % Plot confidence interval as shaded area
        color = groupColorMap(grpName);
        x_fill = [x_common, fliplr(x_common)];
        y_fill = [group_stats.mean + ci_bounds, fliplr(group_stats.mean - ci_bounds)];
        fill(x_fill, y_fill, color, 'FaceAlpha', 0.2, 'EdgeColor', 'none', 'HandleVisibility', 'off');
        
        % Create label using conductor distance if available
        if isKey(measurements_map, grpName)
            height_val = measurements_map(grpName);
            groupLabel = sprintf('d: %s in (n=%d)', height_val, round(mean(group_stats.n)));
        elseif strcmp(grpName, 'Z00')
            groupLabel = sprintf('Control (n=%d)', round(mean(group_stats.n)));
        else
            groupLabel = sprintf('%s (n=%d)', grpName, round(mean(group_stats.n)));
        end
        
        % Plot main line
        plot(x_common, group_stats.mean, 'Color', color, 'LineWidth', 1.5, 'DisplayName', groupLabel);
    end
    
    % Add feeder line length as vertical dashed line if specified
    if ~isempty(l)
        % Convert feeder length to time using VOP = 0.66
        vop = 0.66;
        speed_of_light_ft_per_s = 983571056; % ft/s
        speed_in_cable = speed_of_light_ft_per_s * vop; % ft/s
        % Round trip time: multiply by 2 (signal goes down and back up)
        feeder_time_ns = (l * 2) / speed_in_cable * 1e9; % Convert to nanoseconds
        
        % Get current y-axis limits to draw line across full height
        ylims = ylim;
        
        % Plot vertical dashed line
        line([feeder_time_ns, feeder_time_ns], ylims, 'Color', 'k', 'LineStyle', '--', ...
             'LineWidth', 1.5, 'DisplayName', 'Feeder Line Length');
    end

    % Add legend and grid
    legend('show', 'Location', 'best');
    grid on;
    hold off;
end

function [x_common, group_stats] = processGroupFilesTime(folderPath, filenames, specificFrequency)
    % Process all files in a group and calculate statistics
    x_common = [];
    group_stats = struct('mean', [], 'std', [], 'n', []);
    
    % Load all files and collect their data
    all_x = {};
    all_y = {};
    valid_files = 0;
    
    for i = 1:length(filenames)
        [x_vals, y_vals] = loadAndProcessFileTime(fullfile(folderPath, filenames{i}), specificFrequency);
        if ~isempty(x_vals)
            all_x{end+1} = x_vals;
            all_y{end+1} = y_vals;
            valid_files = valid_files + 1;
        end
    end
    
    if valid_files == 0
        return;
    end
    
    % Find common x-axis range across all files
    x_min = max(cellfun(@min, all_x));
    x_max = min(cellfun(@max, all_x));
    
    % Use the finest resolution among all files
    dx_vals = cellfun(@(x) mean(diff(x)), all_x);
    dx = min(dx_vals);
    
    x_common = x_min:dx:x_max;
    
    if length(x_common) < 2
        return;
    end
    
    % Interpolate all signals to common x-axis
    y_matrix = zeros(length(x_common), valid_files);
    
    for i = 1:valid_files
        y_interp = interp1(all_x{i}, all_y{i}, x_common, 'linear', 'extrap');
        y_matrix(:, i) = y_interp;
    end
    
    % Calculate statistics across replicates at each x position
    group_stats.mean = mean(y_matrix, 2)';
    group_stats.std = std(y_matrix, 0, 2)'; % Sample standard deviation
    group_stats.n = repmat(valid_files, size(group_stats.mean)); % Number of replicates
    
    % Handle case where std is 0 (all replicates identical)
    min_std = 0.001 * (max(group_stats.mean) - min(group_stats.mean));
    group_stats.std = max(group_stats.std, min_std);
end

function [x_vals, y_vals] = loadAndProcessFileTime(fullFilePath, specificFrequency)
    % Load and process a single CSV file, converting distance to time
    x_vals = [];
    y_vals = [];
    
    try
        opts = detectImportOptions(fullFilePath);
        % Ensure certain columns are read as strings
        forceStringCols = {'UnitsPerSample', 'ZeroIndex', 'Units', 'MeasurementFrequency', 'DataType', 'VOP'};
        for k = 1:numel(forceStringCols)
            col = forceStringCols{k};
            if any(strcmp(opts.VariableNames, col))
                opts = setvartype(opts, col, 'string');
            end
        end
        tbl = readtable(fullFilePath, opts);
    catch ME
        warning('Failed to read %s: %s', fullFilePath, char(ME.message));
        return;
    end

    % Filter for waveform data at the specified frequency
    isWave = strcmpi(tbl.DataType, 'Waveform');
    isFreq = tbl.MeasurementFrequency == specificFrequency;
    data = tbl(isWave & isFreq, :);
    if isempty(data)
        return;
    end

    % Compute normalized Y values
    y_raw = data.Value;
    max_abs_y = max(abs(y_raw));
    if max_abs_y == 0
        y_vals = zeros(size(y_raw));
    else
        y_vals = y_raw / max_abs_y;
    end

    % Get VOP value from the data
    vop_str = data.VOP(1);
    vop = str2double(vop_str);
    if isnan(vop) || vop <= 0
        vop = 0.66; % Default VOP value
    end

    % Compute X values (distance in feet, shifted by zero index)
    idx = data.DataIndex;
    % UnitsPerSample conversion
    ups_str = data.UnitsPerSample(1);
    ups = str2double(ups_str);
    if isnan(ups) || ups <= 0
        ups = 1.0;
    end
    raw_dist = idx * ups;
    % Metric vs Standard units
    unitStr = data.Units(1);
    isMetric = strcmpi(unitStr, 'Metric');
    METERS_TO_FEET = 3.28084;
    dist_ft = raw_dist * (isMetric * METERS_TO_FEET + ~isMetric);

    % ZeroIndex offset
    zi_str = data.ZeroIndex(1);
    zi = str2double(zi_str);
    if isnan(zi)
        zi = 0;
    end
    zero_offset = zi * ups * (isMetric * METERS_TO_FEET + ~isMetric);
    dist_ft_corrected = dist_ft - zero_offset;
    
    % Convert distance to time using VOP and speed of light
    % time = distance / (speed_of_light * VOP)
    % Speed of light = 299,792,458 m/s = 983,571,056 ft/s
    speed_of_light_ft_per_s = 983571056; % ft/s
    speed_in_cable = speed_of_light_ft_per_s * vop; % ft/s
    
    % Convert to time in nanoseconds
    % Round trip time: multiply by 2 (signal goes down and back up)
    x_vals = (dist_ft_corrected * 2) / speed_in_cable * 1e9; % Convert to nanoseconds
end 